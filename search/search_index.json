{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"signalrgb-python","text":"<p>Welcome to the documentation for signalrgb-python! This library provides a powerful and easy-to-use interface for controlling SignalRGB Pro through both a command-line interface (CLI) and Python libraries (both synchronous and asynchronous).</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83d\udccb List available lighting effects and presets</li> <li>\ud83d\udd0d Get detailed information about specific effects</li> <li>\ud83c\udfa8 Apply effects and presets to your devices with ease</li> <li>\ud83d\uddbc\ufe0f Manage and switch between different layouts</li> <li>\ud83d\udd06 Control brightness levels</li> <li>\ud83d\udd0c Enable or disable the canvas</li> <li>\ud83d\udda5\ufe0f User-friendly command-line interface with intuitive subcommands</li> <li>\ud83d\udc0d Python client libraries for seamless integration:</li> <li>Synchronous API for straightforward scripts</li> <li>Asynchronous API for asyncio-based applications</li> <li>\ud83d\udd10 Robust error handling and connection management</li> <li>\ud83d\udd04 Automatic effect caching for improved performance</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install signalrgb\n</code></pre>"},{"location":"#command-line-interface","title":"Command-Line Interface","text":"<p>List available effects:</p> <pre><code>signalrgb effect list\n</code></pre> <p>Apply a specific effect:</p> <pre><code>signalrgb effect apply \"Rainbow Wave\"\n</code></pre>"},{"location":"#synchronous-python-api","title":"Synchronous Python API","text":"<pre><code>from signalrgb import SignalRGBClient\n\n# Initialize the client\nclient = SignalRGBClient()\n\n# Apply an effect\nclient.apply_effect_by_name(\"Rainbow Wave\")\n\n# Control brightness\nclient.brightness = 75\n\n# Enable/disable the canvas\nclient.enabled = True\n\n# Get current effect information\neffect = client.get_current_effect()\nprint(f\"Current effect: {effect.attributes.name}\")\n</code></pre>"},{"location":"#asynchronous-python-api","title":"Asynchronous Python API","text":"<pre><code>import asyncio\nfrom signalrgb import AsyncSignalRGBClient\n\nasync def main():\n    # Use the async client as a context manager\n    async with AsyncSignalRGBClient() as client:\n        # Apply an effect\n        await client.apply_effect_by_name(\"Rainbow Wave\")\n\n        # Control brightness\n        await client.set_brightness(75)\n\n        # Get current effect information\n        effect = await client.get_current_effect()\n        print(f\"Current effect: {effect.attributes.name}\")\n\n# Run the async code\nasyncio.run(main())\n</code></pre>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Installation - Detailed installation instructions</li> <li>Usage Guides:</li> <li>Command-Line Interface - Using the SignalRGB CLI</li> <li>Synchronous Library - Using the Python library in synchronous code</li> <li>Asynchronous Library - Using the async Python library with asyncio</li> <li>API Reference:</li> <li>Client API - SignalRGBClient reference</li> <li>Models - Data model reference</li> <li>Development:</li> <li>Contributing - Guidelines for contributors</li> <li>Development Guide - Setting up your development environment</li> </ul>"},{"location":"async_usage/","title":"Using the Async SignalRGB Client","text":"<p>Starting from version 1.0.0, signalrgb-python includes a native asyncio-based client that allows you to integrate SignalRGB functionality with async code. This is particularly useful for applications built on asyncio, such as Home Assistant integrations or asynchronous web applications.</p>"},{"location":"async_usage/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":"<p>The <code>AsyncSignalRGBClient</code> provides the same functionality as the synchronous client but with async/await syntax:</p> <pre><code>import asyncio\nfrom signalrgb import AsyncSignalRGBClient\n\nasync def main():\n    # Create a client\n    async with AsyncSignalRGBClient() as client:\n        # Get current effect\n        effect = await client.get_current_effect()\n        print(f\"Current effect: {effect.attributes.name}\")\n\n        # List available effects\n        effects = await client.get_effects()\n        print(f\"Available effects: {len(effects)}\")\n\n        # Apply a random effect\n        new_effect = await client.apply_random_effect()\n        print(f\"Applied effect: {new_effect.attributes.name}\")\n\n# Run the async code\nasyncio.run(main())\n</code></pre>"},{"location":"async_usage/#comparison-with-synchronous-client","title":"\ud83d\udcca Comparison with Synchronous Client","text":"<p>The async client provides the same functionality as the synchronous client but with async/await syntax:</p> Synchronous Client Asynchronous Client <code>client.get_effects()</code> <code>await client.get_effects()</code> <code>client.apply_effect(id)</code> <code>await client.apply_effect(id)</code> <code>client.brightness = 50</code> <code>await client.set_brightness(50)</code> <code>client.enabled = True</code> <code>await client.set_enabled(True)</code>"},{"location":"async_usage/#properties-vs-methods","title":"\ud83d\udd04 Properties vs Methods","text":"<p>Unlike the synchronous client, the asynchronous client uses methods instead of properties for read/write operations, since properties in Python can't be async:</p> Synchronous Client Asynchronous Client <code>client.brightness</code> <code>await client.get_brightness()</code> <code>client.brightness = 50</code> <code>await client.set_brightness(50)</code> <code>client.enabled</code> <code>await client.get_enabled()</code> <code>client.enabled = True</code> <code>await client.set_enabled(True)</code> <code>client.current_layout</code> <code>await client.get_current_layout()</code> <code>client.current_layout = \"layout\"</code> <code>await client.set_current_layout(\"layout\")</code>"},{"location":"async_usage/#integration-with-home-assistant","title":"\ud83c\udfe0 Integration with Home Assistant","text":"<p>The async client is particularly well-suited for integrating with Home Assistant, which uses asyncio for its operations:</p> <pre><code>from homeassistant.components.light import LightEntity\nfrom signalrgb import AsyncSignalRGBClient\n\nclass SignalRGBLight(LightEntity):\n    def __init__(self, client):\n        self._client = client\n        self._name = \"SignalRGB\"\n        self._state = False\n        self._brightness = 0\n\n    async def async_turn_on(self, **kwargs):\n        await self._client.set_enabled(True)\n        if \"brightness\" in kwargs:\n            # Home Assistant brightness is 0-255, SignalRGB is 0-100\n            brightness = round(kwargs[\"brightness\"] / 255 * 100)\n            await self._client.set_brightness(brightness)\n        self._state = True\n\n    async def async_turn_off(self, **kwargs):\n        await self._client.set_enabled(False)\n        self._state = False\n\n    async def async_update(self):\n        self._state = await self._client.get_enabled()\n        self._brightness = await self._client.get_brightness()\n</code></pre> <p>See the <code>examples/home_assistant_example.py</code> file for a more complete Home Assistant integration example.</p>"},{"location":"async_usage/#context-manager-support","title":"\ud83d\udce6 Context Manager Support","text":"<p>The async client supports being used as an async context manager, which ensures proper cleanup of resources:</p> <pre><code>async with AsyncSignalRGBClient() as client:\n    # client is automatically closed when exiting this block\n    await client.get_effects()\n</code></pre> <p>You can also manually close the client:</p> <pre><code>client = AsyncSignalRGBClient()\ntry:\n    await client.get_effects()\nfinally:\n    await client.aclose()\n</code></pre>"},{"location":"async_usage/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":"<p>The async client raises the same exceptions as the synchronous client. Always use try/except blocks to catch and handle potential errors:</p> <pre><code>try:\n    await client.apply_effect_by_name(\"nonexistent_effect\")\nexcept NotFoundError:\n    print(\"Effect not found\")\nexcept ConnectionError:\n    print(\"Connection error\")\nexcept APIError as e:\n    print(f\"API error: {e}\")\n</code></pre>"},{"location":"async_usage/#backward-compatibility","title":"\ud83d\udd04 Backward Compatibility","text":"<p>The synchronous client is still available and fully functional. In fact, it now uses the async client internally, running operations in a synchronized manner. This allows existing code to continue working without changes.</p> <p>If you're using the client in a synchronous context but need to call it from async code in some places, you can mix approaches:</p> <pre><code># In synchronous code\nfrom signalrgb import SignalRGBClient\n\nclient = SignalRGBClient()\neffects = client.get_effects()\n\n# Later, in an async context\nasync def async_function():\n    # Use the async client directly\n    async with AsyncSignalRGBClient() as async_client:\n        await async_client.apply_effect_by_name(\"some_effect\")\n</code></pre>"},{"location":"async_usage/#performance-considerations","title":"\ud83d\ude80 Performance Considerations","text":"<p>The async client can offer better performance in async applications, especially when:</p> <ul> <li>Making multiple concurrent requests</li> <li>Integrating with other async code like Home Assistant</li> <li>Operating in event-loop based applications</li> <li>Processing many effects/devices simultaneously</li> </ul> <p>It avoids blocking the event loop while waiting for API responses, allowing your application to remain responsive while processing SignalRGB operations.</p>"},{"location":"async_usage/#advanced-example-effect-cycling","title":"\ud83d\udca1 Advanced Example: Effect Cycling","text":"<p>Here's a more advanced example that cycles through all available effects, displaying each for a specified duration:</p> <pre><code>import asyncio\nfrom signalrgb import AsyncSignalRGBClient\n\nasync def cycle_effects(duration=5):\n    \"\"\"Cycle through all effects, displaying each for the specified duration.\"\"\"\n    async with AsyncSignalRGBClient() as client:\n        effects = await client.get_effects()\n        print(f\"Cycling through {len(effects)} effects...\")\n\n        for effect in effects:\n            print(f\"Applying effect: {effect.attributes.name}\")\n            await client.apply_effect(effect.id)\n            await asyncio.sleep(duration)\n\nif __name__ == \"__main__\":\n    asyncio.run(cycle_effects(duration=3))\n</code></pre> <p>This example demonstrates how to leverage the async capabilities to create a non-blocking effect showcase application.</p>"},{"location":"contributing/","title":"Contributing to signalrgb-python","text":"<p>Thank you for your interest in contributing to signalrgb-python! This guide will help you get started with contributing to the project.</p>"},{"location":"contributing/#what-should-i-know-before-i-get-started","title":"\ud83e\uddd0 What should I know before I get started?","text":""},{"location":"contributing/#project-structure","title":"Project Structure","text":"<ul> <li><code>signalrgb/</code> - This directory contains the main source code for the project.</li> <li><code>tests/</code> - This directory contains all the tests.</li> <li><code>docs/</code> - This directory contains the project documentation.</li> <li><code>examples/</code> - This directory contains example scripts demonstrating how to use the library.</li> </ul>"},{"location":"contributing/#how-can-i-contribute","title":"\ud83e\udd1d How Can I Contribute?","text":""},{"location":"contributing/#reporting-bugs","title":"\ud83d\udc1b Reporting Bugs","text":"<p>This section guides you through submitting a bug report for signalrgb-python. Following these guidelines helps maintainers and the community understand your report, reproduce the behavior, and find related reports.</p> <ul> <li>Use a clear and descriptive title for the issue to identify the problem.</li> <li>Describe the exact steps which reproduce the problem in as many details as possible.</li> <li>Provide specific examples to demonstrate the steps.</li> <li>Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior.</li> <li>Explain which behavior you expected to see instead and why.</li> <li>Include screenshots and animated GIFs which show you following the described steps and clearly demonstrate the problem.</li> </ul>"},{"location":"contributing/#suggesting-enhancements","title":"\ud83d\udca1 Suggesting Enhancements","text":"<p>This section guides you through submitting an enhancement suggestion for signalrgb-python, including completely new features and minor improvements to existing functionality.</p> <ul> <li>Use a clear and descriptive title for the issue to identify the suggestion.</li> <li>Provide a step-by-step description of the suggested enhancement in as many details as possible.</li> <li>Provide specific examples to demonstrate the steps.</li> <li>Describe the current behavior and explain which behavior you expected to see instead and why.</li> <li>Explain why this enhancement would be useful to most signalrgb-python users.</li> <li>List some other text editors or applications where this enhancement exists.</li> </ul>"},{"location":"contributing/#your-first-code-contribution","title":"\ud83d\ude80 Your First Code Contribution","text":"<p>Unsure where to begin contributing to signalrgb-python? You can start by looking through these <code>beginner</code> and <code>help-wanted</code> issues:</p> <ul> <li>Beginner issues - issues which should only require a few lines of code, and a test or two.</li> <li>Help wanted issues - issues which should be a bit more involved than <code>beginner</code> issues.</li> </ul>"},{"location":"contributing/#pull-requests","title":"\ud83d\udce5 Pull Requests","text":"<ul> <li>Fill in the required template</li> <li>Do not include issue numbers in the PR title</li> <li>Follow the Python style guide</li> <li>Include thoughtfully-worded, well-structured tests in the <code>./tests</code> folder. Run them using <code>pytest</code>.</li> <li>Document new code based on the Documentation Styleguide</li> <li>End all files with a newline</li> </ul>"},{"location":"contributing/#styleguides","title":"\ud83d\udcdd Styleguides","text":""},{"location":"contributing/#git-commit-messages","title":"Git Commit Messages","text":"<ul> <li>Use the present tense (\"Add feature\" not \"Added feature\")</li> <li>Use the imperative mood (\"Move cursor to...\" not \"Moves cursor to...\")</li> <li>Limit the first line to 72 characters or less</li> <li>Reference issues and pull requests liberally after the first line</li> <li>Consider starting the commit message with an applicable emoji:</li> <li>:art: <code>:art:</code> when improving the format/structure of the code</li> <li>:racehorse: <code>:racehorse:</code> when improving performance</li> <li>:non-potable_water: <code>:non-potable_water:</code> when plugging memory leaks</li> <li>:memo: <code>:memo:</code> when writing docs</li> <li>:penguin: <code>:penguin:</code> when fixing something on Linux</li> <li>:apple: <code>:apple:</code> when fixing something on macOS</li> <li>:checkered_flag: <code>:checkered_flag:</code> when fixing something on Windows</li> <li>:bug: <code>:bug:</code> when fixing a bug</li> <li>:fire: <code>:fire:</code> when removing code or files</li> <li>:green_heart: <code>:green_heart:</code> when fixing the CI build</li> <li>:white_check_mark: <code>:white_check_mark:</code> when adding tests</li> <li>:lock: <code>:lock:</code> when dealing with security</li> <li>:arrow_up: <code>:arrow_up:</code> when upgrading dependencies</li> <li>:arrow_down: <code>:arrow_down:</code> when downgrading dependencies</li> <li>:shirt: <code>:shirt:</code> when removing linter warnings</li> </ul>"},{"location":"contributing/#python-styleguide","title":"Python Styleguide","text":"<p>All Python code must adhere to PEP 8.</p>"},{"location":"contributing/#documentation-styleguide","title":"Documentation Styleguide","text":"<ul> <li>Use Markdown.</li> <li>Use Google-style docstrings for Python code.</li> </ul>"},{"location":"contributing/#additional-notes","title":"\ud83d\udccb Additional Notes","text":""},{"location":"contributing/#issue-and-pull-request-labels","title":"Issue and Pull Request Labels","text":"<p>This section lists the labels we use to help us track and manage issues and pull requests.</p> <p>GitHub search makes it easy to use labels for finding groups of issues or pull requests you're interested in.</p>"},{"location":"contributing/#type-of-issue-and-issue-state","title":"Type of Issue and Issue State","text":"<ul> <li><code>bug</code> - Issues that are bugs.</li> <li><code>enhancement</code> - Issues that are feature requests.</li> <li><code>question</code> - Issues that are questions.</li> <li><code>duplicate</code> - Issues that are duplicates of other issues.</li> <li><code>good first issue</code> - Issues that are good for newcomers.</li> <li><code>help wanted</code> - Issues that need assistance from the community.</li> </ul>"},{"location":"contributing/#topic-categories","title":"Topic Categories","text":"<ul> <li><code>documentation</code> - Issues related to documentation.</li> <li><code>performance</code> - Issues related to performance.</li> <li><code>security</code> - Issues related to security.</li> </ul>"},{"location":"contributing/#pull-request-labels","title":"Pull Request Labels","text":"<ul> <li><code>work-in-progress</code> - Pull requests that are still being worked on, more changes will follow.</li> <li><code>needs-review</code> - Pull requests that need code review and approval from maintainers.</li> <li><code>under-review</code> - Pull requests being reviewed by maintainers.</li> <li><code>requires-changes</code> - Pull requests that need to be updated based on review comments and then reviewed again.</li> <li><code>needs-testing</code> - Pull requests that need manual testing.</li> </ul> <p>Thank you for your contributions to signalrgb-python!</p>"},{"location":"development/","title":"Development Guide","text":"<p>This guide will help you set up your development environment for contributing to signalrgb-python.</p>"},{"location":"development/#prerequisites","title":"\ud83e\uddf0 Prerequisites","text":"<p>Before you begin, ensure you have the following installed on your system:</p> <ul> <li>Python 3.9 or higher</li> <li>UV for dependency management</li> <li>Git for version control</li> </ul>"},{"location":"development/#setting-up-the-development-environment","title":"\ud83d\ude80 Setting Up the Development Environment","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/hyperb1iss/signalrgb-python.git\ncd signalrgb-python\n</code></pre> <ol> <li>Install the project dependencies using UV:</li> </ol> <pre><code>uv sync --groups dev\n</code></pre> <ol> <li>To run commands in the development environment:</li> </ol> <pre><code>uv run [command]\n</code></pre> <p>For example, to run a Python script:</p> <pre><code>uv run python scripts/some_script.py\n</code></pre>"},{"location":"development/#running-tests","title":"\ud83e\uddea Running Tests","text":"<p>We use pytest for our test suite. To run the tests:</p> <pre><code>uv run pytest\n</code></pre> <p>To run tests with coverage report:</p> <pre><code>uv run pytest --cov=signalrgb --cov-report=term-missing\n</code></pre>"},{"location":"development/#linting","title":"\ud83d\udd0d Linting","text":"<p>We use Ruff for linting and formatting. To run the linter:</p> <pre><code>uv run ruff check .\n</code></pre> <p>To automatically fix linting issues:</p> <pre><code>uv run ruff check --fix .\n</code></pre>"},{"location":"development/#type-checking","title":"\ud83d\udd0e Type Checking","text":"<p>We use mypy for static type checking. To run the type checker:</p> <pre><code>uv run mypy signalrgb\n</code></pre>"},{"location":"development/#pre-commit-hooks","title":"\ud83d\udd04 Pre-commit Hooks","text":"<p>We use pre-commit hooks to ensure code quality before committing. To set up pre-commit hooks:</p> <ol> <li>Install pre-commit:</li> </ol> <pre><code>uv run pre-commit install\n</code></pre> <ol> <li>Run pre-commit on all files:    <pre><code>uv run pre-commit run --all-files\n</code></pre></li> </ol> <p>The pre-commit hooks will now run automatically on <code>git commit</code>.</p>"},{"location":"development/#building-documentation","title":"\ud83d\udcda Building Documentation","text":"<p>To build the documentation locally:</p> <ol> <li>Make sure you've installed the development dependencies:</li> </ol> <pre><code>uv sync --groups dev\n</code></pre> <ol> <li>Build and serve the documentation:</li> </ol> <pre><code>uv run mkdocs serve\n</code></pre> <ol> <li>Open your browser and navigate to <code>http://127.0.0.1:8000/</code> to view the documentation.</li> </ol>"},{"location":"development/#creating-a-new-release","title":"\ud83d\udce6 Creating a New Release","text":"<ol> <li>Update the version number in <code>pyproject.toml</code>:</li> </ol> <pre><code># Edit manually or use a version update script\n</code></pre> <ol> <li> <p>Update the <code>CHANGELOG.md</code> file with the changes for the new version.</p> </li> <li> <p>Commit the changes:</p> </li> </ol> <pre><code>git add pyproject.toml CHANGELOG.md\ngit commit -m \"Bump version to x.y.z\"\n</code></pre> <ol> <li>Create a new tag:</li> </ol> <pre><code>git tag -a vx.y.z -m \"Release version x.y.z\"\n</code></pre> <ol> <li>Push the changes and the new tag:    <pre><code>git push origin main --tags\n</code></pre></li> </ol> <p>The CI/CD pipeline will handle the rest, including building and publishing the package to PyPI and deploying the updated documentation.</p>"},{"location":"development/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":"<p>If you encounter any issues during development, please check the following:</p> <ol> <li>Ensure you're using the correct version of Python (3.9+).</li> <li>Make sure all dependencies are up to date (<code>uv sync</code>).</li> <li>Clear any cached files:    <pre><code>find . -name '*.pyc' -delete\nfind . -name '__pycache__' -type d -delete\n</code></pre></li> </ol> <p>If you're still having problems, please open an issue on the GitHub repository with a detailed description of the problem and steps to reproduce it.</p>"},{"location":"development/#getting-help","title":"\ud83d\udcac Getting Help","text":"<p>If you need help with development, you can:</p> <ol> <li>Open an issue on the GitHub repository.</li> <li>Reach out to the maintainers directly (contact information can be found in the <code>README.md</code> file).</li> </ol>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"\ud83e\uddf0 Prerequisites","text":"<p>Before installing signalrgb-python, ensure you have the following:</p> <ul> <li>Python 3.9 or higher</li> <li>SignalRGB Pro (required for API access)</li> </ul> <p>This library uses the SignalRGB REST API, which is only available in SignalRGB Pro.</p>"},{"location":"installation/#additional-requirements-for-async-usage","title":"Additional Requirements for Async Usage","text":"<p>To use the asynchronous client (<code>AsyncSignalRGBClient</code>), you will need:</p> <ul> <li>Python 3.9 or higher (same as above)</li> <li>Basic understanding of Python's asyncio framework</li> <li>For integration with other async frameworks (like Home Assistant), see the Async Usage guide</li> </ul>"},{"location":"installation/#installing-with-pip","title":"\ud83d\udce6 Installing with pip","text":"<p>The easiest way to install signalrgb-python is using pip:</p> <pre><code>pip install signalrgb\n</code></pre>"},{"location":"installation/#installing-with-uv","title":"\ud83d\ude80 Installing with UV","text":"<p>For faster, more reliable dependency resolution, you can use UV to install signalrgb-python:</p> <pre><code># Install UV if you don't have it already\npip install uv\n\n# Install signalrgb using UV\nuv pip install signalrgb\n</code></pre>"},{"location":"installation/#development-installation","title":"\ud83d\udd27 Development Installation","text":"<p>If you're working on signalrgb-python development, you can install it with development dependencies:</p> <pre><code># Clone the repository\ngit clone https://github.com/hyperb1iss/signalrgb-python.git\ncd signalrgb-python\n\n# Using UV\nuv sync --groups dev\n</code></pre>"},{"location":"installation/#verifying-the-installation","title":"\u2705 Verifying the Installation","text":"<p>After installation, you can verify that signalrgb-python is correctly installed by running:</p> <pre><code>signalrgb --version\n</code></pre> <p>This should display the version number of the installed client.</p> <p>You can also verify the Python library is working by importing it in a Python shell:</p> <pre><code>import signalrgb\nprint(signalrgb.__version__)\n</code></pre>"},{"location":"installation/#next-steps","title":"\ud83d\udcda Next Steps","text":"<p>Now that you have installed signalrgb-python, you can start using it:</p> <ul> <li>CLI Usage - Learn how to use the command-line interface</li> <li>Python Library Usage - Learn how to use the synchronous Python library</li> <li>Async Library Usage - Learn how to use the asynchronous Python library</li> </ul>"},{"location":"api/client/","title":"SignalRGB Client API Reference","text":"<p>This page provides detailed API documentation for both the synchronous <code>SignalRGBClient</code> class and the asynchronous <code>AsyncSignalRGBClient</code> class, which are the main interfaces for interacting with the SignalRGB API.</p>"},{"location":"api/client/#signalrgbclient","title":"SignalRGBClient","text":""},{"location":"api/client/#signalrgb.client.SignalRGBClient","title":"<code>signalrgb.client.SignalRGBClient</code>","text":"<p>Client for interacting with the SignalRGB API.</p> <p>This class provides methods to interact with the SignalRGB API, allowing users to retrieve, apply, and manage lighting effects and layouts.</p> <p>This class is a wrapper around the AsyncSignalRGBClient that provides a synchronous interface to the API. Most methods simply delegate to the async client.</p> Source code in <code>signalrgb/client.py</code> <pre><code>class SignalRGBClient:\n    \"\"\"Client for interacting with the SignalRGB API.\n\n    This class provides methods to interact with the SignalRGB API, allowing users\n    to retrieve, apply, and manage lighting effects and layouts.\n\n    This class is a wrapper around the AsyncSignalRGBClient that provides a synchronous\n    interface to the API. Most methods simply delegate to the async client.\n    \"\"\"\n\n    def __init__(self, host: str = DEFAULT_HOST, port: int = DEFAULT_PORT, timeout: float = DEFAULT_TIMEOUT):\n        \"\"\"Initialize the SignalRGBClient.\n\n        Args:\n            host: The host of the SignalRGB API. Defaults to 'localhost'.\n            port: The port of the SignalRGB API. Defaults to DEFAULT_PORT.\n            timeout: The timeout for API requests in seconds. Defaults to 10.0.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; client = SignalRGBClient(\"192.168.1.100\", 8080, 5.0)\n        \"\"\"\n        self._base_url = f\"http://{host}:{port}\"\n        self._timeout = timeout\n        self._effects_cache: list[Effect] | None = None\n        # For backward compatibility, we still maintain the session\n        self._session = requests.Session()\n        # Create an AsyncSignalRGBClient for internal use\n        self._async_client = AsyncSignalRGBClient(host, port, timeout)\n        # Create and manage an event loop for running async code\n        self._loop = asyncio.new_event_loop()\n\n    def __enter__(self) -&gt; SignalRGBClient:\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n        \"\"\"Context manager exit.\"\"\"\n        self._session.close()\n        try:\n            # Close the async client if the loop is still running\n            if not self._loop.is_closed():\n                self._loop.run_until_complete(self._async_client.aclose())\n                self._loop.close()\n        except RuntimeError:\n            # The loop might already be closed, just ignore\n            pass\n\n    def _run_async(self, coro: Awaitable[T]) -&gt; T:\n        \"\"\"Run an asynchronous coroutine in a synchronous context.\n\n        Args:\n            coro: The coroutine to run.\n\n        Returns:\n            The result of the coroutine with preserved type.\n        \"\"\"\n        try:\n            if self._loop.is_closed():\n                self._loop = asyncio.new_event_loop()\n            return self._loop.run_until_complete(coro)\n        except RuntimeError as e:\n            # If we get a runtime error about the event loop, create a new one\n            if \"This event loop is already running\" in str(e):\n                # Create a new event loop for this thread\n                new_loop = asyncio.new_event_loop()\n                asyncio.set_event_loop(new_loop)\n                self._loop = new_loop\n                return self._loop.run_until_complete(coro)\n            raise\n\n    # Using a standard method with cached property pattern instead of lru_cache on method\n    def _get_effects_cached(self) -&gt; list[Effect]:\n        \"\"\"Internal method to get effects with caching.\"\"\"\n        return self._run_async(self._async_client.get_effects_cached())\n\n    def get_effects(self) -&gt; list[Effect]:\n        \"\"\"List available effects.\n\n        Returns:\n            List[Effect]: A list of available effects.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an error retrieving the effects.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; effects = client.get_effects()\n            &gt;&gt;&gt; print(f\"Found {len(effects)} effects\")\n        \"\"\"\n        return self._run_async(self._async_client.get_effects())\n\n    def get_effect(self, effect_id: str) -&gt; Effect:\n        \"\"\"Get details of a specific effect.\n\n        Args:\n            effect_id (str): The ID of the effect to retrieve.\n\n        Returns:\n            Effect: The requested effect.\n\n        Raises:\n            NotFoundError: If the effect with the given ID is not found.\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; effect = client.get_effect(\"example_effect_id\")\n            &gt;&gt;&gt; print(f\"Effect name: {effect.attributes.name}\")\n        \"\"\"\n        return self._run_async(self._async_client.get_effect(effect_id))\n\n    def get_effect_by_name(self, effect_name: str) -&gt; Effect:\n        \"\"\"Get details of a specific effect by name.\n\n        Args:\n            effect_name: The name of the effect to retrieve.\n\n        Returns:\n            Effect: The requested effect.\n\n        Raises:\n            NotFoundError: If the effect with the given name is not found.\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; effect = client.get_effect_by_name(\"Rainbow Wave\")\n            &gt;&gt;&gt; print(f\"Effect ID: {effect.id}\")\n        \"\"\"\n        return self._run_async(self._async_client.get_effect_by_name(effect_name))\n\n    @property\n    def current_effect(self) -&gt; Effect:\n        \"\"\"Get the current effect.\n\n        Returns:\n            Effect: The currently active effect.\n\n        Raises:\n            APIError: If there's an error retrieving the current effect.\n        \"\"\"\n        return self.get_current_effect()\n\n    def get_current_effect(self) -&gt; Effect:\n        \"\"\"Get the current effect.\n\n        Returns:\n            Effect: The currently active effect.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; current_effect = client.get_current_effect()\n            &gt;&gt;&gt; print(f\"Current effect: {current_effect.attributes.name}\")\n        \"\"\"\n        return self._run_async(self._async_client.get_current_effect())\n\n    def _get_current_state(self) -&gt; Any:  # Using Any for CurrentStateHolder\n        \"\"\"Get the current state of the SignalRGB instance.\n\n        Returns:\n            CurrentStateHolder: The current state of the SignalRGB instance.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n        \"\"\"\n        return self._run_async(self._async_client.get_current_state())\n\n    @property\n    def brightness(self) -&gt; int:\n        \"\"\"Get or set the current brightness level.\n\n        Returns:\n            int: The current brightness level (0-100).\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; print(f\"Current brightness: {client.brightness}\")\n            &gt;&gt;&gt; client.brightness = 75\n            &gt;&gt;&gt; print(f\"New brightness: {client.brightness}\")\n        \"\"\"\n        return self._run_async(self._async_client.get_brightness())\n\n    @brightness.setter\n    def brightness(self, value: int) -&gt; None:\n        self._run_async(self._async_client.set_brightness(value))\n\n    @property\n    def enabled(self) -&gt; bool:\n        \"\"\"Get or set the current enabled state of the canvas.\n\n        Returns:\n            bool: The current enabled state.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; print(f\"Canvas enabled: {client.enabled}\")\n            &gt;&gt;&gt; client.enabled = False\n            &gt;&gt;&gt; print(f\"Canvas now disabled: {not client.enabled}\")\n        \"\"\"\n        return self._run_async(self._async_client.get_enabled())\n\n    @enabled.setter\n    def enabled(self, value: bool) -&gt; None:\n        self._run_async(self._async_client.set_enabled(value))\n\n    def apply_effect(self, effect_id: str) -&gt; None:\n        \"\"\"Apply an effect.\n\n        Args:\n            effect_id (str): The ID of the effect to apply.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; client.apply_effect(\"example_effect_id\")\n            &gt;&gt;&gt; print(\"Effect applied successfully\")\n        \"\"\"\n        self._run_async(self._async_client.apply_effect(effect_id))\n\n    def apply_effect_by_name(self, effect_name: str) -&gt; None:\n        \"\"\"Apply an effect by name.\n\n        Args:\n            effect_name: The name of the effect to apply.\n\n        Raises:\n            NotFoundError: If the effect with the given name is not found.\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; client.apply_effect_by_name(\"Rainbow Wave\")\n            &gt;&gt;&gt; print(\"Effect applied successfully\")\n        \"\"\"\n        self._run_async(self._async_client.apply_effect_by_name(effect_name))\n\n    def get_effect_presets(self, effect_id: str) -&gt; list[EffectPreset]:\n        \"\"\"Get presets for a specific effect.\n\n        Args:\n            effect_id (str): The ID of the effect to retrieve presets for.\n\n        Returns:\n            List[EffectPreset]: A list of effect presets.\n\n        Raises:\n            NotFoundError: If the effect with the given ID is not found.\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; presets = client.get_effect_presets(\"example_effect_id\")\n            &gt;&gt;&gt; for preset in presets:\n            ...     print(f\"Preset ID: {preset.id}, Name: {preset.name}\")\n        \"\"\"\n        return self._run_async(self._async_client.get_effect_presets(effect_id))\n\n    def apply_effect_preset(self, effect_id: str, preset_id: str) -&gt; None:\n        \"\"\"Apply a preset for a specific effect.\n\n        Args:\n            effect_id (str): The ID of the effect to apply the preset to.\n            preset_id (str): The ID of the preset to apply.\n\n        Raises:\n            NotFoundError: If the effect with the given ID is not found.\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; client.apply_effect_preset(\"example_effect_id\", \"My Fancy Preset 1\")\n            &gt;&gt;&gt; print(\"Preset applied successfully\")\n        \"\"\"\n        self._run_async(self._async_client.apply_effect_preset(effect_id, preset_id))\n\n    def get_next_effect(self) -&gt; Effect | None:\n        \"\"\"Get information about the next effect in history.\n\n        Returns:\n            Optional[Effect]: The next effect if available, None otherwise.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; next_effect = client.get_next_effect()\n            &gt;&gt;&gt; if next_effect:\n            ...     print(f\"Next effect: {next_effect.attributes.name}\")\n            ... else:\n            ...     print(\"No next effect available\")\n        \"\"\"\n        return self._run_async(self._async_client.get_next_effect())\n\n    def apply_next_effect(self) -&gt; Effect:\n        \"\"\"Apply the next effect in history or a random effect if there's no next effect.\n\n        Returns:\n            Effect: The newly applied effect.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; new_effect = client.apply_next_effect()\n            &gt;&gt;&gt; print(f\"Applied effect: {new_effect.attributes.name}\")\n        \"\"\"\n        return self._run_async(self._async_client.apply_next_effect())\n\n    def get_previous_effect(self) -&gt; Effect | None:\n        \"\"\"Get information about the previous effect in history.\n\n        Returns:\n            Optional[Effect]: The previous effect if available, None otherwise.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; prev_effect = client.get_previous_effect()\n            &gt;&gt;&gt; if prev_effect:\n            ...     print(f\"Previous effect: {prev_effect.attributes.name}\")\n            ... else:\n            ...     print(\"No previous effect available\")\n        \"\"\"\n        return self._run_async(self._async_client.get_previous_effect())\n\n    def apply_previous_effect(self) -&gt; Effect:\n        \"\"\"Apply the previous effect in history.\n\n        Returns:\n            Effect: The newly applied effect.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; new_effect = client.apply_previous_effect()\n            &gt;&gt;&gt; print(f\"Applied effect: {new_effect.attributes.name}\")\n        \"\"\"\n        return self._run_async(self._async_client.apply_previous_effect())\n\n    def apply_random_effect(self) -&gt; Effect:\n        \"\"\"Apply a random effect.\n\n        Returns:\n            Effect: The newly applied random effect.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; random_effect = client.apply_random_effect()\n            &gt;&gt;&gt; print(f\"Applied random effect: {random_effect.attributes.name}\")\n        \"\"\"\n        return self._run_async(self._async_client.apply_random_effect())\n\n    @property\n    def current_layout(self) -&gt; Layout:\n        \"\"\"Get the current layout.\n\n        Returns:\n            Layout: The currently active layout.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; current_layout = client.current_layout\n            &gt;&gt;&gt; print(f\"Current layout: {current_layout.id}\")\n        \"\"\"\n        return self._run_async(self._async_client.get_current_layout())\n\n    @current_layout.setter\n    def current_layout(self, layout_id: str) -&gt; None:\n        \"\"\"Set the current layout.\n\n        Args:\n            layout_id: The ID of the layout to set as current.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; client.current_layout = \"My Layout 1\"\n            &gt;&gt;&gt; print(f\"New current layout: {client.current_layout.id}\")\n        \"\"\"\n        self._run_async(self._async_client.set_current_layout(layout_id))\n\n    def get_layouts(self) -&gt; list[Layout]:\n        \"\"\"Get all available layouts.\n\n        Returns:\n            List[Layout]: A list of all available layouts.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; layouts = client.get_layouts()\n            &gt;&gt;&gt; for layout in layouts:\n            ...     print(f\"Layout: {layout.id}\")\n        \"\"\"\n        return self._run_async(self._async_client.get_layouts())\n\n    def refresh_effects(self) -&gt; None:\n        \"\"\"Refresh the cached effects.\n\n        This method clears the cache for the get_effects method, forcing a fresh\n        retrieval of effects on the next call.\n\n        Example:\n            &gt;&gt;&gt; client = SignalRGBClient()\n            &gt;&gt;&gt; client.refresh_effects()\n            &gt;&gt;&gt; fresh_effects = client.get_effects()\n        \"\"\"\n        self._run_async(self._async_client.refresh_effects())\n\n    def __repr__(self) -&gt; str:\n        return f\"SignalRGBClient(base_url='{self._base_url}')\"\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.brightness","title":"<code>brightness</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the current brightness level.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current brightness level (0-100).</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() print(f\"Current brightness: {client.brightness}\") client.brightness = 75 print(f\"New brightness: {client.brightness}\")</p>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.current_effect","title":"<code>current_effect</code>  <code>property</code>","text":"<p>Get the current effect.</p> <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The currently active effect.</p> <p>Raises:</p> Type Description <code>APIError</code> <p>If there's an error retrieving the current effect.</p>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.current_layout","title":"<code>current_layout</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current layout.</p> <p>Returns:</p> Name Type Description <code>Layout</code> <code>Layout</code> <p>The currently active layout.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() current_layout = client.current_layout print(f\"Current layout: {current_layout.id}\")</p>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.enabled","title":"<code>enabled</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the current enabled state of the canvas.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>The current enabled state.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() print(f\"Canvas enabled: {client.enabled}\") client.enabled = False print(f\"Canvas now disabled: {not client.enabled}\")</p>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>signalrgb/client.py</code> <pre><code>def __enter__(self) -&gt; SignalRGBClient:\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>signalrgb/client.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"Context manager exit.\"\"\"\n    self._session.close()\n    try:\n        # Close the async client if the loop is still running\n        if not self._loop.is_closed():\n            self._loop.run_until_complete(self._async_client.aclose())\n            self._loop.close()\n    except RuntimeError:\n        # The loop might already be closed, just ignore\n        pass\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.__init__","title":"<code>__init__(host=DEFAULT_HOST, port=DEFAULT_PORT, timeout=DEFAULT_TIMEOUT)</code>","text":"<p>Initialize the SignalRGBClient.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host of the SignalRGB API. Defaults to 'localhost'.</p> <code>DEFAULT_HOST</code> <code>port</code> <code>int</code> <p>The port of the SignalRGB API. Defaults to DEFAULT_PORT.</p> <code>DEFAULT_PORT</code> <code>timeout</code> <code>float</code> <p>The timeout for API requests in seconds. Defaults to 10.0.</p> <code>DEFAULT_TIMEOUT</code> Example <p>client = SignalRGBClient() client = SignalRGBClient(\"192.168.1.100\", 8080, 5.0)</p> Source code in <code>signalrgb/client.py</code> <pre><code>def __init__(self, host: str = DEFAULT_HOST, port: int = DEFAULT_PORT, timeout: float = DEFAULT_TIMEOUT):\n    \"\"\"Initialize the SignalRGBClient.\n\n    Args:\n        host: The host of the SignalRGB API. Defaults to 'localhost'.\n        port: The port of the SignalRGB API. Defaults to DEFAULT_PORT.\n        timeout: The timeout for API requests in seconds. Defaults to 10.0.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; client = SignalRGBClient(\"192.168.1.100\", 8080, 5.0)\n    \"\"\"\n    self._base_url = f\"http://{host}:{port}\"\n    self._timeout = timeout\n    self._effects_cache: list[Effect] | None = None\n    # For backward compatibility, we still maintain the session\n    self._session = requests.Session()\n    # Create an AsyncSignalRGBClient for internal use\n    self._async_client = AsyncSignalRGBClient(host, port, timeout)\n    # Create and manage an event loop for running async code\n    self._loop = asyncio.new_event_loop()\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient._get_current_state","title":"<code>_get_current_state()</code>","text":"<p>Get the current state of the SignalRGB instance.</p> <p>Returns:</p> Name Type Description <code>CurrentStateHolder</code> <code>Any</code> <p>The current state of the SignalRGB instance.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Source code in <code>signalrgb/client.py</code> <pre><code>def _get_current_state(self) -&gt; Any:  # Using Any for CurrentStateHolder\n    \"\"\"Get the current state of the SignalRGB instance.\n\n    Returns:\n        CurrentStateHolder: The current state of the SignalRGB instance.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n    \"\"\"\n    return self._run_async(self._async_client.get_current_state())\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient._get_effects_cached","title":"<code>_get_effects_cached()</code>","text":"<p>Internal method to get effects with caching.</p> Source code in <code>signalrgb/client.py</code> <pre><code>def _get_effects_cached(self) -&gt; list[Effect]:\n    \"\"\"Internal method to get effects with caching.\"\"\"\n    return self._run_async(self._async_client.get_effects_cached())\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient._run_async","title":"<code>_run_async(coro)</code>","text":"<p>Run an asynchronous coroutine in a synchronous context.</p> <p>Parameters:</p> Name Type Description Default <code>coro</code> <code>Awaitable[T]</code> <p>The coroutine to run.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The result of the coroutine with preserved type.</p> Source code in <code>signalrgb/client.py</code> <pre><code>def _run_async(self, coro: Awaitable[T]) -&gt; T:\n    \"\"\"Run an asynchronous coroutine in a synchronous context.\n\n    Args:\n        coro: The coroutine to run.\n\n    Returns:\n        The result of the coroutine with preserved type.\n    \"\"\"\n    try:\n        if self._loop.is_closed():\n            self._loop = asyncio.new_event_loop()\n        return self._loop.run_until_complete(coro)\n    except RuntimeError as e:\n        # If we get a runtime error about the event loop, create a new one\n        if \"This event loop is already running\" in str(e):\n            # Create a new event loop for this thread\n            new_loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(new_loop)\n            self._loop = new_loop\n            return self._loop.run_until_complete(coro)\n        raise\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.apply_effect","title":"<code>apply_effect(effect_id)</code>","text":"<p>Apply an effect.</p> <p>Parameters:</p> Name Type Description Default <code>effect_id</code> <code>str</code> <p>The ID of the effect to apply.</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() client.apply_effect(\"example_effect_id\") print(\"Effect applied successfully\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def apply_effect(self, effect_id: str) -&gt; None:\n    \"\"\"Apply an effect.\n\n    Args:\n        effect_id (str): The ID of the effect to apply.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; client.apply_effect(\"example_effect_id\")\n        &gt;&gt;&gt; print(\"Effect applied successfully\")\n    \"\"\"\n    self._run_async(self._async_client.apply_effect(effect_id))\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.apply_effect_by_name","title":"<code>apply_effect_by_name(effect_name)</code>","text":"<p>Apply an effect by name.</p> <p>Parameters:</p> Name Type Description Default <code>effect_name</code> <code>str</code> <p>The name of the effect to apply.</p> required <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the effect with the given name is not found.</p> <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() client.apply_effect_by_name(\"Rainbow Wave\") print(\"Effect applied successfully\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def apply_effect_by_name(self, effect_name: str) -&gt; None:\n    \"\"\"Apply an effect by name.\n\n    Args:\n        effect_name: The name of the effect to apply.\n\n    Raises:\n        NotFoundError: If the effect with the given name is not found.\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; client.apply_effect_by_name(\"Rainbow Wave\")\n        &gt;&gt;&gt; print(\"Effect applied successfully\")\n    \"\"\"\n    self._run_async(self._async_client.apply_effect_by_name(effect_name))\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.apply_effect_preset","title":"<code>apply_effect_preset(effect_id, preset_id)</code>","text":"<p>Apply a preset for a specific effect.</p> <p>Parameters:</p> Name Type Description Default <code>effect_id</code> <code>str</code> <p>The ID of the effect to apply the preset to.</p> required <code>preset_id</code> <code>str</code> <p>The ID of the preset to apply.</p> required <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the effect with the given ID is not found.</p> <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() client.apply_effect_preset(\"example_effect_id\", \"My Fancy Preset 1\") print(\"Preset applied successfully\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def apply_effect_preset(self, effect_id: str, preset_id: str) -&gt; None:\n    \"\"\"Apply a preset for a specific effect.\n\n    Args:\n        effect_id (str): The ID of the effect to apply the preset to.\n        preset_id (str): The ID of the preset to apply.\n\n    Raises:\n        NotFoundError: If the effect with the given ID is not found.\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; client.apply_effect_preset(\"example_effect_id\", \"My Fancy Preset 1\")\n        &gt;&gt;&gt; print(\"Preset applied successfully\")\n    \"\"\"\n    self._run_async(self._async_client.apply_effect_preset(effect_id, preset_id))\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.apply_next_effect","title":"<code>apply_next_effect()</code>","text":"<p>Apply the next effect in history or a random effect if there's no next effect.</p> <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The newly applied effect.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() new_effect = client.apply_next_effect() print(f\"Applied effect: {new_effect.attributes.name}\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def apply_next_effect(self) -&gt; Effect:\n    \"\"\"Apply the next effect in history or a random effect if there's no next effect.\n\n    Returns:\n        Effect: The newly applied effect.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; new_effect = client.apply_next_effect()\n        &gt;&gt;&gt; print(f\"Applied effect: {new_effect.attributes.name}\")\n    \"\"\"\n    return self._run_async(self._async_client.apply_next_effect())\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.apply_previous_effect","title":"<code>apply_previous_effect()</code>","text":"<p>Apply the previous effect in history.</p> <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The newly applied effect.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() new_effect = client.apply_previous_effect() print(f\"Applied effect: {new_effect.attributes.name}\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def apply_previous_effect(self) -&gt; Effect:\n    \"\"\"Apply the previous effect in history.\n\n    Returns:\n        Effect: The newly applied effect.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; new_effect = client.apply_previous_effect()\n        &gt;&gt;&gt; print(f\"Applied effect: {new_effect.attributes.name}\")\n    \"\"\"\n    return self._run_async(self._async_client.apply_previous_effect())\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.apply_random_effect","title":"<code>apply_random_effect()</code>","text":"<p>Apply a random effect.</p> <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The newly applied random effect.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() random_effect = client.apply_random_effect() print(f\"Applied random effect: {random_effect.attributes.name}\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def apply_random_effect(self) -&gt; Effect:\n    \"\"\"Apply a random effect.\n\n    Returns:\n        Effect: The newly applied random effect.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; random_effect = client.apply_random_effect()\n        &gt;&gt;&gt; print(f\"Applied random effect: {random_effect.attributes.name}\")\n    \"\"\"\n    return self._run_async(self._async_client.apply_random_effect())\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.get_current_effect","title":"<code>get_current_effect()</code>","text":"<p>Get the current effect.</p> <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The currently active effect.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() current_effect = client.get_current_effect() print(f\"Current effect: {current_effect.attributes.name}\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def get_current_effect(self) -&gt; Effect:\n    \"\"\"Get the current effect.\n\n    Returns:\n        Effect: The currently active effect.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; current_effect = client.get_current_effect()\n        &gt;&gt;&gt; print(f\"Current effect: {current_effect.attributes.name}\")\n    \"\"\"\n    return self._run_async(self._async_client.get_current_effect())\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.get_effect","title":"<code>get_effect(effect_id)</code>","text":"<p>Get details of a specific effect.</p> <p>Parameters:</p> Name Type Description Default <code>effect_id</code> <code>str</code> <p>The ID of the effect to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The requested effect.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the effect with the given ID is not found.</p> <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() effect = client.get_effect(\"example_effect_id\") print(f\"Effect name: {effect.attributes.name}\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def get_effect(self, effect_id: str) -&gt; Effect:\n    \"\"\"Get details of a specific effect.\n\n    Args:\n        effect_id (str): The ID of the effect to retrieve.\n\n    Returns:\n        Effect: The requested effect.\n\n    Raises:\n        NotFoundError: If the effect with the given ID is not found.\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; effect = client.get_effect(\"example_effect_id\")\n        &gt;&gt;&gt; print(f\"Effect name: {effect.attributes.name}\")\n    \"\"\"\n    return self._run_async(self._async_client.get_effect(effect_id))\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.get_effect_by_name","title":"<code>get_effect_by_name(effect_name)</code>","text":"<p>Get details of a specific effect by name.</p> <p>Parameters:</p> Name Type Description Default <code>effect_name</code> <code>str</code> <p>The name of the effect to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The requested effect.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the effect with the given name is not found.</p> <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() effect = client.get_effect_by_name(\"Rainbow Wave\") print(f\"Effect ID: {effect.id}\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def get_effect_by_name(self, effect_name: str) -&gt; Effect:\n    \"\"\"Get details of a specific effect by name.\n\n    Args:\n        effect_name: The name of the effect to retrieve.\n\n    Returns:\n        Effect: The requested effect.\n\n    Raises:\n        NotFoundError: If the effect with the given name is not found.\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; effect = client.get_effect_by_name(\"Rainbow Wave\")\n        &gt;&gt;&gt; print(f\"Effect ID: {effect.id}\")\n    \"\"\"\n    return self._run_async(self._async_client.get_effect_by_name(effect_name))\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.get_effect_presets","title":"<code>get_effect_presets(effect_id)</code>","text":"<p>Get presets for a specific effect.</p> <p>Parameters:</p> Name Type Description Default <code>effect_id</code> <code>str</code> <p>The ID of the effect to retrieve presets for.</p> required <p>Returns:</p> Type Description <code>list[EffectPreset]</code> <p>List[EffectPreset]: A list of effect presets.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the effect with the given ID is not found.</p> <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() presets = client.get_effect_presets(\"example_effect_id\") for preset in presets: ...     print(f\"Preset ID: {preset.id}, Name: {preset.name}\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def get_effect_presets(self, effect_id: str) -&gt; list[EffectPreset]:\n    \"\"\"Get presets for a specific effect.\n\n    Args:\n        effect_id (str): The ID of the effect to retrieve presets for.\n\n    Returns:\n        List[EffectPreset]: A list of effect presets.\n\n    Raises:\n        NotFoundError: If the effect with the given ID is not found.\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; presets = client.get_effect_presets(\"example_effect_id\")\n        &gt;&gt;&gt; for preset in presets:\n        ...     print(f\"Preset ID: {preset.id}, Name: {preset.name}\")\n    \"\"\"\n    return self._run_async(self._async_client.get_effect_presets(effect_id))\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.get_effects","title":"<code>get_effects()</code>","text":"<p>List available effects.</p> <p>Returns:</p> Type Description <code>list[Effect]</code> <p>List[Effect]: A list of available effects.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an error retrieving the effects.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() effects = client.get_effects() print(f\"Found {len(effects)} effects\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def get_effects(self) -&gt; list[Effect]:\n    \"\"\"List available effects.\n\n    Returns:\n        List[Effect]: A list of available effects.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an error retrieving the effects.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; effects = client.get_effects()\n        &gt;&gt;&gt; print(f\"Found {len(effects)} effects\")\n    \"\"\"\n    return self._run_async(self._async_client.get_effects())\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.get_layouts","title":"<code>get_layouts()</code>","text":"<p>Get all available layouts.</p> <p>Returns:</p> Type Description <code>list[Layout]</code> <p>List[Layout]: A list of all available layouts.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() layouts = client.get_layouts() for layout in layouts: ...     print(f\"Layout: {layout.id}\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def get_layouts(self) -&gt; list[Layout]:\n    \"\"\"Get all available layouts.\n\n    Returns:\n        List[Layout]: A list of all available layouts.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; layouts = client.get_layouts()\n        &gt;&gt;&gt; for layout in layouts:\n        ...     print(f\"Layout: {layout.id}\")\n    \"\"\"\n    return self._run_async(self._async_client.get_layouts())\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.get_next_effect","title":"<code>get_next_effect()</code>","text":"<p>Get information about the next effect in history.</p> <p>Returns:</p> Type Description <code>Effect | None</code> <p>Optional[Effect]: The next effect if available, None otherwise.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() next_effect = client.get_next_effect() if next_effect: ...     print(f\"Next effect: {next_effect.attributes.name}\") ... else: ...     print(\"No next effect available\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def get_next_effect(self) -&gt; Effect | None:\n    \"\"\"Get information about the next effect in history.\n\n    Returns:\n        Optional[Effect]: The next effect if available, None otherwise.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; next_effect = client.get_next_effect()\n        &gt;&gt;&gt; if next_effect:\n        ...     print(f\"Next effect: {next_effect.attributes.name}\")\n        ... else:\n        ...     print(\"No next effect available\")\n    \"\"\"\n    return self._run_async(self._async_client.get_next_effect())\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.get_previous_effect","title":"<code>get_previous_effect()</code>","text":"<p>Get information about the previous effect in history.</p> <p>Returns:</p> Type Description <code>Effect | None</code> <p>Optional[Effect]: The previous effect if available, None otherwise.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>client = SignalRGBClient() prev_effect = client.get_previous_effect() if prev_effect: ...     print(f\"Previous effect: {prev_effect.attributes.name}\") ... else: ...     print(\"No previous effect available\")</p> Source code in <code>signalrgb/client.py</code> <pre><code>def get_previous_effect(self) -&gt; Effect | None:\n    \"\"\"Get information about the previous effect in history.\n\n    Returns:\n        Optional[Effect]: The previous effect if available, None otherwise.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; prev_effect = client.get_previous_effect()\n        &gt;&gt;&gt; if prev_effect:\n        ...     print(f\"Previous effect: {prev_effect.attributes.name}\")\n        ... else:\n        ...     print(\"No previous effect available\")\n    \"\"\"\n    return self._run_async(self._async_client.get_previous_effect())\n</code></pre>"},{"location":"api/client/#signalrgb.client.SignalRGBClient.refresh_effects","title":"<code>refresh_effects()</code>","text":"<p>Refresh the cached effects.</p> <p>This method clears the cache for the get_effects method, forcing a fresh retrieval of effects on the next call.</p> Example <p>client = SignalRGBClient() client.refresh_effects() fresh_effects = client.get_effects()</p> Source code in <code>signalrgb/client.py</code> <pre><code>def refresh_effects(self) -&gt; None:\n    \"\"\"Refresh the cached effects.\n\n    This method clears the cache for the get_effects method, forcing a fresh\n    retrieval of effects on the next call.\n\n    Example:\n        &gt;&gt;&gt; client = SignalRGBClient()\n        &gt;&gt;&gt; client.refresh_effects()\n        &gt;&gt;&gt; fresh_effects = client.get_effects()\n    \"\"\"\n    self._run_async(self._async_client.refresh_effects())\n</code></pre>"},{"location":"api/client/#asyncsignalrgbclient","title":"AsyncSignalRGBClient","text":""},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient","title":"<code>signalrgb.async_client.AsyncSignalRGBClient</code>","text":"<p>Async client for interacting with the SignalRGB API.</p> <p>This class provides asynchronous methods to interact with the SignalRGB API, allowing users to retrieve, apply, and manage lighting effects and layouts.</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>class AsyncSignalRGBClient:\n    \"\"\"Async client for interacting with the SignalRGB API.\n\n    This class provides asynchronous methods to interact with the SignalRGB API, allowing users\n    to retrieve, apply, and manage lighting effects and layouts.\n    \"\"\"\n\n    def __init__(self, host: str = DEFAULT_HOST, port: int = DEFAULT_PORT, timeout: float = DEFAULT_TIMEOUT):\n        \"\"\"Initialize the AsyncSignalRGBClient.\n\n        Args:\n            host: The host of the SignalRGB API. Defaults to 'localhost'.\n            port: The port of the SignalRGB API. Defaults to DEFAULT_PORT.\n            timeout: The timeout for API requests in seconds. Defaults to 10.0.\n\n        Example:\n            &gt;&gt;&gt; client = AsyncSignalRGBClient()\n            &gt;&gt;&gt; client = AsyncSignalRGBClient(\"192.168.1.100\", 8080, 5.0)\n        \"\"\"\n        self._base_url = f\"http://{host}:{port}\"\n        self._timeout = timeout\n        self._effects_cache: list[Effect] | None = None\n        self._client = httpx.AsyncClient(timeout=self._timeout)\n\n    async def __aenter__(self) -&gt; AsyncSignalRGBClient:\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n        \"\"\"Async context manager exit.\"\"\"\n        if self._client:\n            await self._client.aclose()\n\n    @property\n    def client(self) -&gt; httpx.AsyncClient:\n        \"\"\"Get the HTTPX client instance.\"\"\"\n        return self._client\n\n    @asynccontextmanager\n    async def _request_context(self, method: str, endpoint: str, **kwargs: Any) -&gt; AsyncIterator[dict[str, Any]]:\n        \"\"\"Async context manager for making API requests.\n\n        This method handles common exception cases and debug logging.\n\n        Args:\n            method: The HTTP method to use for the request.\n            endpoint: The API endpoint to request.\n            **kwargs: Additional arguments to pass to the request.\n\n        Yields:\n            The JSON response from the API.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n        \"\"\"\n        url = f\"{self._base_url}{endpoint}\"\n        debug = os.getenv(DEBUG_ENV_VAR, \"0\") == \"1\"\n\n        if debug:\n            pass\n\n        try:\n            response = await self.client.request(method, url, **kwargs)\n            response.raise_for_status()\n\n            if debug:\n                pass\n\n            yield response.json()\n        except httpx.ConnectError as e:\n            raise ConnectionError(f\"Failed to connect to SignalRGB API: {e}\", Error(title=str(e))) from e\n        except httpx.TimeoutException as e:\n            raise ConnectionError(\"Request timed out\", Error(title=\"Request Timeout\")) from e\n        except httpx.HTTPStatusError as e:\n            # Create error object based on response\n            error: Error\n            if e.response is not None and hasattr(e.response, \"json\"):\n                try:\n                    json_data = e.response.json()\n                    if \"errors\" in json_data and json_data[\"errors\"] and isinstance(json_data[\"errors\"], list):\n                        error = Error.from_dict(json_data[\"errors\"][0])\n                    else:\n                        error = Error(title=str(e))\n                except Exception:  # noqa: BLE001\n                    error = Error(title=str(e))\n            else:\n                error = Error(title=str(e))\n            raise APIError(f\"HTTP error occurred: {e}\", error) from e\n        except httpx.RequestError as e:\n            error = Error(title=str(e))\n            raise APIError(f\"An error occurred while making the request: {e}\", error) from e\n        except (ValueError, TypeError) as e:\n            # More specific exceptions instead of catching generic Exception\n            raise SignalRGBError(f\"An unexpected error occurred: {e}\") from e\n\n    async def _get_effects_cached(self) -&gt; list[Effect]:\n        \"\"\"Internal method to get effects with caching.\"\"\"\n        if self._effects_cache is None:\n            async with self._request_context(\"GET\", f\"{LIGHTING_V1}/effects\") as data:\n                response = EffectListResponse.from_dict(data)\n                self._ensure_response_ok(response)\n                effects = response.data\n                if effects is None or effects.items is None:\n                    raise APIError(\"No effects data in the response\")\n                self._effects_cache = effects.items\n        return self._effects_cache\n\n    async def get_effects(self) -&gt; list[Effect]:\n        \"\"\"List available effects asynchronously.\n\n        Returns:\n            List[Effect]: A list of available effects.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an error retrieving the effects.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     effects = await client.get_effects()\n            &gt;&gt;&gt;     print(f\"Found {len(effects)} effects\")\n        \"\"\"\n        return await self._get_effects_cached()\n\n    async def get_effect(self, effect_id: str) -&gt; Effect:\n        \"\"\"Get details of a specific effect asynchronously.\n\n        Args:\n            effect_id (str): The ID of the effect to retrieve.\n\n        Returns:\n            Effect: The requested effect.\n\n        Raises:\n            NotFoundError: If the effect with the given ID is not found.\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     effect = await client.get_effect(\"example_effect_id\")\n            &gt;&gt;&gt;     print(f\"Effect name: {effect.attributes.name}\")\n        \"\"\"\n        try:\n            async with self._request_context(\"GET\", f\"{LIGHTING_V1}/effects/{effect_id}\") as data:\n                response = EffectDetailsResponse.from_dict(data)\n                self._ensure_response_ok(response)\n                if response.data is None:\n                    raise APIError(\"No effect data in the response\")\n                return response.data\n        except APIError as e:\n            if e.error and e.error.code == \"not_found\":\n                raise NotFoundError(f\"Effect with ID '{effect_id}' not found\", e.error) from e\n            raise\n\n    async def get_effect_by_name(self, effect_name: str) -&gt; Effect:\n        \"\"\"Get details of a specific effect by name asynchronously.\n\n        Args:\n            effect_name: The name of the effect to retrieve.\n\n        Returns:\n            Effect: The requested effect.\n\n        Raises:\n            NotFoundError: If the effect with the given name is not found.\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     effect = await client.get_effect_by_name(\"Rainbow Wave\")\n            &gt;&gt;&gt;     print(f\"Effect ID: {effect.id}\")\n        \"\"\"\n        effects = await self.get_effects()\n        effect = next((e for e in effects if e.attributes.name == effect_name), None)\n        if effect is None:\n            raise NotFoundError(f\"Effect '{effect_name}' not found\")\n        return await self.get_effect(effect.id)\n\n    async def get_current_effect(self) -&gt; Effect:\n        \"\"\"Get the current effect asynchronously.\n\n        Returns:\n            Effect: The currently active effect.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     current_effect = await client.get_current_effect()\n            &gt;&gt;&gt;     print(f\"Current effect: {current_effect.attributes.name}\")\n        \"\"\"\n        state = await self._get_current_state()\n        if state.attributes is None:\n            raise APIError(\"No current effect data in the response\")\n        return await self.get_effect(state.id)\n\n    async def _get_current_state(self) -&gt; CurrentStateHolder:\n        \"\"\"Get the current state of the SignalRGB instance asynchronously.\n\n        Returns:\n            CurrentStateHolder: The current state of the SignalRGB instance.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n        \"\"\"\n        async with self._request_context(\"GET\", LIGHTING_V1) as data:\n            response = CurrentStateResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            if response.data is None:\n                raise APIError(\"No current state data in the response\")\n            return response.data\n\n    async def get_brightness(self) -&gt; int:\n        \"\"\"Get the current brightness level asynchronously.\n\n        Returns:\n            int: The current brightness level (0-100).\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     brightness = await client.get_brightness()\n            &gt;&gt;&gt;     print(f\"Current brightness: {brightness}\")\n        \"\"\"\n        state = await self._get_current_state()\n        return state.attributes.global_brightness\n\n    async def set_brightness(self, value: int) -&gt; None:\n        \"\"\"Set the brightness level asynchronously.\n\n        Args:\n            value: The brightness level to set (0-100).\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     await client.set_brightness(75)\n            &gt;&gt;&gt;     print(\"Brightness set to 75%\")\n        \"\"\"\n        async with self._request_context(\n            \"PATCH\",\n            f\"{LIGHTING_V1}/global_brightness\",\n            json={\"global_brightness\": value},\n        ):\n            pass\n\n    async def get_enabled(self) -&gt; bool:\n        \"\"\"Get the current enabled state of the canvas asynchronously.\n\n        Returns:\n            bool: The current enabled state.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     enabled = await client.get_enabled()\n            &gt;&gt;&gt;     print(f\"Canvas enabled: {enabled}\")\n        \"\"\"\n        state = await self._get_current_state()\n        return state.attributes.enabled\n\n    async def set_enabled(self, value: bool) -&gt; None:\n        \"\"\"Set the enabled state of the canvas asynchronously.\n\n        Args:\n            value: Whether to enable the canvas.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     await client.set_enabled(False)\n            &gt;&gt;&gt;     print(\"Canvas disabled\")\n        \"\"\"\n        async with self._request_context(\"PATCH\", f\"{LIGHTING_V1}/enabled\", json={\"enabled\": value}):\n            pass\n\n    async def apply_effect(self, effect_id: str) -&gt; None:\n        \"\"\"Apply an effect asynchronously.\n\n        Args:\n            effect_id (str): The ID of the effect to apply.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     await client.apply_effect(\"example_effect_id\")\n            &gt;&gt;&gt;     print(\"Effect applied successfully\")\n        \"\"\"\n        async with self._request_context(\"POST\", f\"{LIGHTING_V1}/effects/{effect_id}/apply\") as data:\n            response = SignalRGBResponse.from_dict(data)\n            self._ensure_response_ok(response)\n\n    async def apply_effect_by_name(self, effect_name: str) -&gt; None:\n        \"\"\"Apply an effect by name asynchronously.\n\n        Args:\n            effect_name: The name of the effect to apply.\n\n        Raises:\n            NotFoundError: If the effect with the given name is not found.\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     await client.apply_effect_by_name(\"Rainbow Wave\")\n            &gt;&gt;&gt;     print(\"Effect applied successfully\")\n        \"\"\"\n        effect = await self.get_effect_by_name(effect_name)\n        apply_url = effect.links.apply\n        if apply_url is None:\n            # Fallback if apply link is missing\n            await self.apply_effect(effect.id)\n        else:\n            async with self._request_context(\"POST\", apply_url):\n                pass\n\n    async def get_effect_presets(self, effect_id: str) -&gt; list[EffectPreset]:\n        \"\"\"Get presets for a specific effect asynchronously.\n\n        Args:\n            effect_id (str): The ID of the effect to retrieve presets for.\n\n        Returns:\n            List[EffectPreset]: A list of effect presets.\n\n        Raises:\n            NotFoundError: If the effect with the given ID is not found.\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     presets = await client.get_effect_presets(\"example_effect_id\")\n            &gt;&gt;&gt;     for preset in presets:\n            &gt;&gt;&gt;         print(f\"Preset ID: {preset.id}\")\n        \"\"\"\n        try:\n            async with self._request_context(\"GET\", f\"{LIGHTING_V1}/effects/{effect_id}/presets\") as data:\n                response = EffectPresetListResponse.from_dict(data)\n                self._ensure_response_ok(response)\n                if response.data is None:\n                    raise APIError(\"No preset data in the response\")\n                return response.data.items\n        except APIError as e:\n            if e.error and e.error.code == \"not_found\":\n                raise NotFoundError(f\"Effect with ID '{effect_id}' not found\", e.error) from e\n            raise\n\n    async def apply_effect_preset(self, effect_id: str, preset_id: str) -&gt; None:\n        \"\"\"Apply a preset for a specific effect asynchronously.\n\n        Args:\n            effect_id (str): The ID of the effect to apply the preset to.\n            preset_id (str): The ID of the preset to apply.\n\n        Raises:\n            NotFoundError: If the effect with the given ID is not found.\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     await client.apply_effect_preset(\"example_effect_id\", \"My Fancy Preset 1\")\n            &gt;&gt;&gt;     print(\"Preset applied successfully\")\n        \"\"\"\n        try:\n            async with self._request_context(\n                \"PATCH\",\n                f\"{LIGHTING_V1}/effects/{effect_id}/presets\",\n                json={\"preset\": preset_id},\n            ) as data:\n                response = EffectPresetResponse.from_dict(data)\n                self._ensure_response_ok(response)\n        except APIError as e:\n            if e.error and e.error.code == \"not_found\":\n                raise NotFoundError(\n                    f\"Effect with ID '{effect_id}' or preset '{preset_id}' not found\",\n                    e.error,\n                ) from e\n            raise\n\n    async def get_next_effect(self) -&gt; Effect | None:\n        \"\"\"Get information about the next effect in history asynchronously.\n\n        Returns:\n            Optional[Effect]: The next effect if available, None otherwise.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     next_effect = await client.get_next_effect()\n            &gt;&gt;&gt;     if next_effect:\n            &gt;&gt;&gt;         print(f\"Next effect: {next_effect.attributes.name}\")\n            &gt;&gt;&gt;     else:\n            &gt;&gt;&gt;         print(\"No next effect available\")\n        \"\"\"\n        try:\n            async with self._request_context(\"GET\", f\"{LIGHTING_V1}/next\") as data:\n                response = EffectDetailsResponse.from_dict(data)\n                self._ensure_response_ok(response)\n                return response.data\n        except APIError as e:\n            if e.error and e.error.code == \"409\":\n                return None\n            raise\n\n    async def apply_next_effect(self) -&gt; Effect:\n        \"\"\"Apply the next effect in history or a random effect if there's no next effect asynchronously.\n\n        Returns:\n            Effect: The newly applied effect.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     new_effect = await client.apply_next_effect()\n            &gt;&gt;&gt;     print(f\"Applied effect: {new_effect.attributes.name}\")\n        \"\"\"\n        async with self._request_context(\"POST\", f\"{LIGHTING_V1}/next\") as data:\n            response = EffectDetailsResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            if response.data is None:\n                raise APIError(\"No effect data in the response\")\n            return response.data\n\n    async def get_previous_effect(self) -&gt; Effect | None:\n        \"\"\"Get information about the previous effect in history asynchronously.\n\n        Returns:\n            Optional[Effect]: The previous effect if available, None otherwise.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     prev_effect = await client.get_previous_effect()\n            &gt;&gt;&gt;     if prev_effect:\n            &gt;&gt;&gt;         print(f\"Previous effect: {prev_effect.attributes.name}\")\n            &gt;&gt;&gt;     else:\n            &gt;&gt;&gt;         print(\"No previous effect available\")\n        \"\"\"\n        try:\n            async with self._request_context(\"GET\", f\"{LIGHTING_V1}/previous\") as data:\n                response = EffectDetailsResponse.from_dict(data)\n                self._ensure_response_ok(response)\n                return response.data\n        except APIError as e:\n            if e.error and e.error.code == \"409\":\n                return None\n            raise\n\n    async def apply_previous_effect(self) -&gt; Effect:\n        \"\"\"Apply the previous effect in history asynchronously.\n\n        Returns:\n            Effect: The newly applied effect.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     new_effect = await client.apply_previous_effect()\n            &gt;&gt;&gt;     print(f\"Applied effect: {new_effect.attributes.name}\")\n        \"\"\"\n        async with self._request_context(\"POST\", f\"{LIGHTING_V1}/previous\") as data:\n            response = EffectDetailsResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            if response.data is None:\n                raise APIError(\"No effect data in the response\")\n            return response.data\n\n    async def apply_random_effect(self) -&gt; Effect:\n        \"\"\"Apply a random effect asynchronously.\n\n        Returns:\n            Effect: The newly applied random effect.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     random_effect = await client.apply_random_effect()\n            &gt;&gt;&gt;     print(f\"Applied random effect: {random_effect.attributes.name}\")\n        \"\"\"\n        async with self._request_context(\"POST\", f\"{LIGHTING_V1}/shuffle\") as data:\n            response = EffectDetailsResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            if response.data is None:\n                raise APIError(\"No effect data in the response\")\n            return response.data\n\n    async def get_current_layout(self) -&gt; Layout:\n        \"\"\"Get the current layout asynchronously.\n\n        Returns:\n            Layout: The currently active layout.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     current_layout = await client.get_current_layout()\n            &gt;&gt;&gt;     print(f\"Current layout: {current_layout.id}\")\n        \"\"\"\n        async with self._request_context(\"GET\", f\"{SCENES_V1}/current_layout\") as data:\n            response = CurrentLayoutResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            if response.data is None or response.data.current_layout is None:\n                raise APIError(\"No current layout data in the response\")\n            return response.data.current_layout\n\n    async def set_current_layout(self, layout_id: str) -&gt; None:\n        \"\"\"Set the current layout asynchronously.\n\n        Args:\n            layout_id: The ID of the layout to set as current.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     await client.set_current_layout(\"My Layout 1\")\n            &gt;&gt;&gt;     current = await client.get_current_layout()\n            &gt;&gt;&gt;     print(f\"New current layout: {current.id}\")\n        \"\"\"\n        async with self._request_context(\"PATCH\", f\"{SCENES_V1}/current_layout\", json={\"layout\": layout_id}) as data:\n            response = CurrentLayoutResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            if response.data is None or response.data.current_layout is None:\n                raise APIError(\"No current layout data in the response\")\n            if response.data.current_layout.id != layout_id:\n                raise APIError(f\"Failed to set layout to '{layout_id}'\")\n\n    async def get_layouts(self) -&gt; list[Layout]:\n        \"\"\"Get all available layouts asynchronously.\n\n        Returns:\n            List[Layout]: A list of all available layouts.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     layouts = await client.get_layouts()\n            &gt;&gt;&gt;     for layout in layouts:\n            &gt;&gt;&gt;         print(f\"Layout: {layout.id}\")\n        \"\"\"\n        async with self._request_context(\"GET\", f\"{SCENES_V1}/layouts\") as data:\n            response = LayoutListResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            if \"data\" not in data or \"items\" not in data[\"data\"]:\n                raise APIError(\"No layouts data in the response\")\n            return [Layout.from_dict(item) for item in data[\"data\"][\"items\"]]\n\n    def _ensure_response_ok(self, response: SignalRGBResponse) -&gt; None:\n        \"\"\"Ensure the response status is 'ok'.\n\n        Args:\n            response: The response to check.\n\n        Raises:\n            APIError: If the response status is not 'ok'.\n        \"\"\"\n        if response.status != \"ok\":\n            error = response.errors[0] if response.errors else None\n            raise APIError(f\"API returned non-OK status: {response.status}\", error)\n\n    async def refresh_effects(self) -&gt; None:\n        \"\"\"Refresh the cached effects asynchronously.\n\n        This method clears the cache for the get_effects method, forcing a fresh\n        retrieval of effects on the next call.\n\n        Example:\n            &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n            &gt;&gt;&gt;     await client.refresh_effects()\n            &gt;&gt;&gt;     fresh_effects = await client.get_effects()\n        \"\"\"\n        self._effects_cache = None\n\n    def __repr__(self) -&gt; str:\n        return f\"AsyncSignalRGBClient(base_url='{self._base_url}')\"\n\n    async def aclose(self) -&gt; None:\n        \"\"\"Close the async client explicitly.\n\n        This method ensures resources are properly released when the client is no longer needed.\n        \"\"\"\n        if self._client:\n            await self._client.aclose()\n\n    async def get_effects_cached(self) -&gt; list[Effect]:\n        \"\"\"Get effects with caching.\n\n        Returns cached effects if available, otherwise retrieves them from the API.\n\n        Returns:\n            List[Effect]: A list of available effects.\n        \"\"\"\n        return await self._get_effects_cached()\n\n    async def get_current_state(self) -&gt; CurrentStateHolder:\n        \"\"\"Get the current state of the SignalRGB instance.\n\n        Returns:\n            CurrentStateHolder: The current state of the SignalRGB instance.\n\n        Raises:\n            ConnectionError: If there's a connection error.\n            APIError: If there's an API error.\n            SignalRGBError: For any other unexpected errors.\n        \"\"\"\n        return await self._get_current_state()\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.client","title":"<code>client</code>  <code>property</code>","text":"<p>Get the HTTPX client instance.</p>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async context manager entry.</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def __aenter__(self) -&gt; AsyncSignalRGBClient:\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async context manager exit.</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"Async context manager exit.\"\"\"\n    if self._client:\n        await self._client.aclose()\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.__init__","title":"<code>__init__(host=DEFAULT_HOST, port=DEFAULT_PORT, timeout=DEFAULT_TIMEOUT)</code>","text":"<p>Initialize the AsyncSignalRGBClient.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host of the SignalRGB API. Defaults to 'localhost'.</p> <code>DEFAULT_HOST</code> <code>port</code> <code>int</code> <p>The port of the SignalRGB API. Defaults to DEFAULT_PORT.</p> <code>DEFAULT_PORT</code> <code>timeout</code> <code>float</code> <p>The timeout for API requests in seconds. Defaults to 10.0.</p> <code>DEFAULT_TIMEOUT</code> Example <p>client = AsyncSignalRGBClient() client = AsyncSignalRGBClient(\"192.168.1.100\", 8080, 5.0)</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>def __init__(self, host: str = DEFAULT_HOST, port: int = DEFAULT_PORT, timeout: float = DEFAULT_TIMEOUT):\n    \"\"\"Initialize the AsyncSignalRGBClient.\n\n    Args:\n        host: The host of the SignalRGB API. Defaults to 'localhost'.\n        port: The port of the SignalRGB API. Defaults to DEFAULT_PORT.\n        timeout: The timeout for API requests in seconds. Defaults to 10.0.\n\n    Example:\n        &gt;&gt;&gt; client = AsyncSignalRGBClient()\n        &gt;&gt;&gt; client = AsyncSignalRGBClient(\"192.168.1.100\", 8080, 5.0)\n    \"\"\"\n    self._base_url = f\"http://{host}:{port}\"\n    self._timeout = timeout\n    self._effects_cache: list[Effect] | None = None\n    self._client = httpx.AsyncClient(timeout=self._timeout)\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient._ensure_response_ok","title":"<code>_ensure_response_ok(response)</code>","text":"<p>Ensure the response status is 'ok'.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>SignalRGBResponse</code> <p>The response to check.</p> required <p>Raises:</p> Type Description <code>APIError</code> <p>If the response status is not 'ok'.</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>def _ensure_response_ok(self, response: SignalRGBResponse) -&gt; None:\n    \"\"\"Ensure the response status is 'ok'.\n\n    Args:\n        response: The response to check.\n\n    Raises:\n        APIError: If the response status is not 'ok'.\n    \"\"\"\n    if response.status != \"ok\":\n        error = response.errors[0] if response.errors else None\n        raise APIError(f\"API returned non-OK status: {response.status}\", error)\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient._get_current_state","title":"<code>_get_current_state()</code>  <code>async</code>","text":"<p>Get the current state of the SignalRGB instance asynchronously.</p> <p>Returns:</p> Name Type Description <code>CurrentStateHolder</code> <code>CurrentStateHolder</code> <p>The current state of the SignalRGB instance.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def _get_current_state(self) -&gt; CurrentStateHolder:\n    \"\"\"Get the current state of the SignalRGB instance asynchronously.\n\n    Returns:\n        CurrentStateHolder: The current state of the SignalRGB instance.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n    \"\"\"\n    async with self._request_context(\"GET\", LIGHTING_V1) as data:\n        response = CurrentStateResponse.from_dict(data)\n        self._ensure_response_ok(response)\n        if response.data is None:\n            raise APIError(\"No current state data in the response\")\n        return response.data\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient._get_effects_cached","title":"<code>_get_effects_cached()</code>  <code>async</code>","text":"<p>Internal method to get effects with caching.</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def _get_effects_cached(self) -&gt; list[Effect]:\n    \"\"\"Internal method to get effects with caching.\"\"\"\n    if self._effects_cache is None:\n        async with self._request_context(\"GET\", f\"{LIGHTING_V1}/effects\") as data:\n            response = EffectListResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            effects = response.data\n            if effects is None or effects.items is None:\n                raise APIError(\"No effects data in the response\")\n            self._effects_cache = effects.items\n    return self._effects_cache\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient._request_context","title":"<code>_request_context(method, endpoint, **kwargs)</code>  <code>async</code>","text":"<p>Async context manager for making API requests.</p> <p>This method handles common exception cases and debug logging.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The HTTP method to use for the request.</p> required <code>endpoint</code> <code>str</code> <p>The API endpoint to request.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the request.</p> <code>{}</code> <p>Yields:</p> Type Description <code>AsyncIterator[dict[str, Any]]</code> <p>The JSON response from the API.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>@asynccontextmanager\nasync def _request_context(self, method: str, endpoint: str, **kwargs: Any) -&gt; AsyncIterator[dict[str, Any]]:\n    \"\"\"Async context manager for making API requests.\n\n    This method handles common exception cases and debug logging.\n\n    Args:\n        method: The HTTP method to use for the request.\n        endpoint: The API endpoint to request.\n        **kwargs: Additional arguments to pass to the request.\n\n    Yields:\n        The JSON response from the API.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n    \"\"\"\n    url = f\"{self._base_url}{endpoint}\"\n    debug = os.getenv(DEBUG_ENV_VAR, \"0\") == \"1\"\n\n    if debug:\n        pass\n\n    try:\n        response = await self.client.request(method, url, **kwargs)\n        response.raise_for_status()\n\n        if debug:\n            pass\n\n        yield response.json()\n    except httpx.ConnectError as e:\n        raise ConnectionError(f\"Failed to connect to SignalRGB API: {e}\", Error(title=str(e))) from e\n    except httpx.TimeoutException as e:\n        raise ConnectionError(\"Request timed out\", Error(title=\"Request Timeout\")) from e\n    except httpx.HTTPStatusError as e:\n        # Create error object based on response\n        error: Error\n        if e.response is not None and hasattr(e.response, \"json\"):\n            try:\n                json_data = e.response.json()\n                if \"errors\" in json_data and json_data[\"errors\"] and isinstance(json_data[\"errors\"], list):\n                    error = Error.from_dict(json_data[\"errors\"][0])\n                else:\n                    error = Error(title=str(e))\n            except Exception:  # noqa: BLE001\n                error = Error(title=str(e))\n        else:\n            error = Error(title=str(e))\n        raise APIError(f\"HTTP error occurred: {e}\", error) from e\n    except httpx.RequestError as e:\n        error = Error(title=str(e))\n        raise APIError(f\"An error occurred while making the request: {e}\", error) from e\n    except (ValueError, TypeError) as e:\n        # More specific exceptions instead of catching generic Exception\n        raise SignalRGBError(f\"An unexpected error occurred: {e}\") from e\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Close the async client explicitly.</p> <p>This method ensures resources are properly released when the client is no longer needed.</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Close the async client explicitly.\n\n    This method ensures resources are properly released when the client is no longer needed.\n    \"\"\"\n    if self._client:\n        await self._client.aclose()\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.apply_effect","title":"<code>apply_effect(effect_id)</code>  <code>async</code>","text":"<p>Apply an effect asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>effect_id</code> <code>str</code> <p>The ID of the effect to apply.</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     await client.apply_effect(\"example_effect_id\")     print(\"Effect applied successfully\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def apply_effect(self, effect_id: str) -&gt; None:\n    \"\"\"Apply an effect asynchronously.\n\n    Args:\n        effect_id (str): The ID of the effect to apply.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     await client.apply_effect(\"example_effect_id\")\n        &gt;&gt;&gt;     print(\"Effect applied successfully\")\n    \"\"\"\n    async with self._request_context(\"POST\", f\"{LIGHTING_V1}/effects/{effect_id}/apply\") as data:\n        response = SignalRGBResponse.from_dict(data)\n        self._ensure_response_ok(response)\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.apply_effect_by_name","title":"<code>apply_effect_by_name(effect_name)</code>  <code>async</code>","text":"<p>Apply an effect by name asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>effect_name</code> <code>str</code> <p>The name of the effect to apply.</p> required <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the effect with the given name is not found.</p> <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     await client.apply_effect_by_name(\"Rainbow Wave\")     print(\"Effect applied successfully\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def apply_effect_by_name(self, effect_name: str) -&gt; None:\n    \"\"\"Apply an effect by name asynchronously.\n\n    Args:\n        effect_name: The name of the effect to apply.\n\n    Raises:\n        NotFoundError: If the effect with the given name is not found.\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     await client.apply_effect_by_name(\"Rainbow Wave\")\n        &gt;&gt;&gt;     print(\"Effect applied successfully\")\n    \"\"\"\n    effect = await self.get_effect_by_name(effect_name)\n    apply_url = effect.links.apply\n    if apply_url is None:\n        # Fallback if apply link is missing\n        await self.apply_effect(effect.id)\n    else:\n        async with self._request_context(\"POST\", apply_url):\n            pass\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.apply_effect_preset","title":"<code>apply_effect_preset(effect_id, preset_id)</code>  <code>async</code>","text":"<p>Apply a preset for a specific effect asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>effect_id</code> <code>str</code> <p>The ID of the effect to apply the preset to.</p> required <code>preset_id</code> <code>str</code> <p>The ID of the preset to apply.</p> required <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the effect with the given ID is not found.</p> <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     await client.apply_effect_preset(\"example_effect_id\", \"My Fancy Preset 1\")     print(\"Preset applied successfully\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def apply_effect_preset(self, effect_id: str, preset_id: str) -&gt; None:\n    \"\"\"Apply a preset for a specific effect asynchronously.\n\n    Args:\n        effect_id (str): The ID of the effect to apply the preset to.\n        preset_id (str): The ID of the preset to apply.\n\n    Raises:\n        NotFoundError: If the effect with the given ID is not found.\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     await client.apply_effect_preset(\"example_effect_id\", \"My Fancy Preset 1\")\n        &gt;&gt;&gt;     print(\"Preset applied successfully\")\n    \"\"\"\n    try:\n        async with self._request_context(\n            \"PATCH\",\n            f\"{LIGHTING_V1}/effects/{effect_id}/presets\",\n            json={\"preset\": preset_id},\n        ) as data:\n            response = EffectPresetResponse.from_dict(data)\n            self._ensure_response_ok(response)\n    except APIError as e:\n        if e.error and e.error.code == \"not_found\":\n            raise NotFoundError(\n                f\"Effect with ID '{effect_id}' or preset '{preset_id}' not found\",\n                e.error,\n            ) from e\n        raise\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.apply_next_effect","title":"<code>apply_next_effect()</code>  <code>async</code>","text":"<p>Apply the next effect in history or a random effect if there's no next effect asynchronously.</p> <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The newly applied effect.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     new_effect = await client.apply_next_effect()     print(f\"Applied effect: {new_effect.attributes.name}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def apply_next_effect(self) -&gt; Effect:\n    \"\"\"Apply the next effect in history or a random effect if there's no next effect asynchronously.\n\n    Returns:\n        Effect: The newly applied effect.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     new_effect = await client.apply_next_effect()\n        &gt;&gt;&gt;     print(f\"Applied effect: {new_effect.attributes.name}\")\n    \"\"\"\n    async with self._request_context(\"POST\", f\"{LIGHTING_V1}/next\") as data:\n        response = EffectDetailsResponse.from_dict(data)\n        self._ensure_response_ok(response)\n        if response.data is None:\n            raise APIError(\"No effect data in the response\")\n        return response.data\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.apply_previous_effect","title":"<code>apply_previous_effect()</code>  <code>async</code>","text":"<p>Apply the previous effect in history asynchronously.</p> <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The newly applied effect.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     new_effect = await client.apply_previous_effect()     print(f\"Applied effect: {new_effect.attributes.name}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def apply_previous_effect(self) -&gt; Effect:\n    \"\"\"Apply the previous effect in history asynchronously.\n\n    Returns:\n        Effect: The newly applied effect.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     new_effect = await client.apply_previous_effect()\n        &gt;&gt;&gt;     print(f\"Applied effect: {new_effect.attributes.name}\")\n    \"\"\"\n    async with self._request_context(\"POST\", f\"{LIGHTING_V1}/previous\") as data:\n        response = EffectDetailsResponse.from_dict(data)\n        self._ensure_response_ok(response)\n        if response.data is None:\n            raise APIError(\"No effect data in the response\")\n        return response.data\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.apply_random_effect","title":"<code>apply_random_effect()</code>  <code>async</code>","text":"<p>Apply a random effect asynchronously.</p> <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The newly applied random effect.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     random_effect = await client.apply_random_effect()     print(f\"Applied random effect: {random_effect.attributes.name}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def apply_random_effect(self) -&gt; Effect:\n    \"\"\"Apply a random effect asynchronously.\n\n    Returns:\n        Effect: The newly applied random effect.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     random_effect = await client.apply_random_effect()\n        &gt;&gt;&gt;     print(f\"Applied random effect: {random_effect.attributes.name}\")\n    \"\"\"\n    async with self._request_context(\"POST\", f\"{LIGHTING_V1}/shuffle\") as data:\n        response = EffectDetailsResponse.from_dict(data)\n        self._ensure_response_ok(response)\n        if response.data is None:\n            raise APIError(\"No effect data in the response\")\n        return response.data\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_brightness","title":"<code>get_brightness()</code>  <code>async</code>","text":"<p>Get the current brightness level asynchronously.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current brightness level (0-100).</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     brightness = await client.get_brightness()     print(f\"Current brightness: {brightness}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_brightness(self) -&gt; int:\n    \"\"\"Get the current brightness level asynchronously.\n\n    Returns:\n        int: The current brightness level (0-100).\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     brightness = await client.get_brightness()\n        &gt;&gt;&gt;     print(f\"Current brightness: {brightness}\")\n    \"\"\"\n    state = await self._get_current_state()\n    return state.attributes.global_brightness\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_current_effect","title":"<code>get_current_effect()</code>  <code>async</code>","text":"<p>Get the current effect asynchronously.</p> <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The currently active effect.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     current_effect = await client.get_current_effect()     print(f\"Current effect: {current_effect.attributes.name}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_current_effect(self) -&gt; Effect:\n    \"\"\"Get the current effect asynchronously.\n\n    Returns:\n        Effect: The currently active effect.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     current_effect = await client.get_current_effect()\n        &gt;&gt;&gt;     print(f\"Current effect: {current_effect.attributes.name}\")\n    \"\"\"\n    state = await self._get_current_state()\n    if state.attributes is None:\n        raise APIError(\"No current effect data in the response\")\n    return await self.get_effect(state.id)\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_current_layout","title":"<code>get_current_layout()</code>  <code>async</code>","text":"<p>Get the current layout asynchronously.</p> <p>Returns:</p> Name Type Description <code>Layout</code> <code>Layout</code> <p>The currently active layout.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     current_layout = await client.get_current_layout()     print(f\"Current layout: {current_layout.id}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_current_layout(self) -&gt; Layout:\n    \"\"\"Get the current layout asynchronously.\n\n    Returns:\n        Layout: The currently active layout.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     current_layout = await client.get_current_layout()\n        &gt;&gt;&gt;     print(f\"Current layout: {current_layout.id}\")\n    \"\"\"\n    async with self._request_context(\"GET\", f\"{SCENES_V1}/current_layout\") as data:\n        response = CurrentLayoutResponse.from_dict(data)\n        self._ensure_response_ok(response)\n        if response.data is None or response.data.current_layout is None:\n            raise APIError(\"No current layout data in the response\")\n        return response.data.current_layout\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_current_state","title":"<code>get_current_state()</code>  <code>async</code>","text":"<p>Get the current state of the SignalRGB instance.</p> <p>Returns:</p> Name Type Description <code>CurrentStateHolder</code> <code>CurrentStateHolder</code> <p>The current state of the SignalRGB instance.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_current_state(self) -&gt; CurrentStateHolder:\n    \"\"\"Get the current state of the SignalRGB instance.\n\n    Returns:\n        CurrentStateHolder: The current state of the SignalRGB instance.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n    \"\"\"\n    return await self._get_current_state()\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_effect","title":"<code>get_effect(effect_id)</code>  <code>async</code>","text":"<p>Get details of a specific effect asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>effect_id</code> <code>str</code> <p>The ID of the effect to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The requested effect.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the effect with the given ID is not found.</p> <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     effect = await client.get_effect(\"example_effect_id\")     print(f\"Effect name: {effect.attributes.name}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_effect(self, effect_id: str) -&gt; Effect:\n    \"\"\"Get details of a specific effect asynchronously.\n\n    Args:\n        effect_id (str): The ID of the effect to retrieve.\n\n    Returns:\n        Effect: The requested effect.\n\n    Raises:\n        NotFoundError: If the effect with the given ID is not found.\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     effect = await client.get_effect(\"example_effect_id\")\n        &gt;&gt;&gt;     print(f\"Effect name: {effect.attributes.name}\")\n    \"\"\"\n    try:\n        async with self._request_context(\"GET\", f\"{LIGHTING_V1}/effects/{effect_id}\") as data:\n            response = EffectDetailsResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            if response.data is None:\n                raise APIError(\"No effect data in the response\")\n            return response.data\n    except APIError as e:\n        if e.error and e.error.code == \"not_found\":\n            raise NotFoundError(f\"Effect with ID '{effect_id}' not found\", e.error) from e\n        raise\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_effect_by_name","title":"<code>get_effect_by_name(effect_name)</code>  <code>async</code>","text":"<p>Get details of a specific effect by name asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>effect_name</code> <code>str</code> <p>The name of the effect to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Effect</code> <code>Effect</code> <p>The requested effect.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the effect with the given name is not found.</p> <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     effect = await client.get_effect_by_name(\"Rainbow Wave\")     print(f\"Effect ID: {effect.id}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_effect_by_name(self, effect_name: str) -&gt; Effect:\n    \"\"\"Get details of a specific effect by name asynchronously.\n\n    Args:\n        effect_name: The name of the effect to retrieve.\n\n    Returns:\n        Effect: The requested effect.\n\n    Raises:\n        NotFoundError: If the effect with the given name is not found.\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     effect = await client.get_effect_by_name(\"Rainbow Wave\")\n        &gt;&gt;&gt;     print(f\"Effect ID: {effect.id}\")\n    \"\"\"\n    effects = await self.get_effects()\n    effect = next((e for e in effects if e.attributes.name == effect_name), None)\n    if effect is None:\n        raise NotFoundError(f\"Effect '{effect_name}' not found\")\n    return await self.get_effect(effect.id)\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_effect_presets","title":"<code>get_effect_presets(effect_id)</code>  <code>async</code>","text":"<p>Get presets for a specific effect asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>effect_id</code> <code>str</code> <p>The ID of the effect to retrieve presets for.</p> required <p>Returns:</p> Type Description <code>list[EffectPreset]</code> <p>List[EffectPreset]: A list of effect presets.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the effect with the given ID is not found.</p> <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     presets = await client.get_effect_presets(\"example_effect_id\")     for preset in presets:         print(f\"Preset ID: {preset.id}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_effect_presets(self, effect_id: str) -&gt; list[EffectPreset]:\n    \"\"\"Get presets for a specific effect asynchronously.\n\n    Args:\n        effect_id (str): The ID of the effect to retrieve presets for.\n\n    Returns:\n        List[EffectPreset]: A list of effect presets.\n\n    Raises:\n        NotFoundError: If the effect with the given ID is not found.\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     presets = await client.get_effect_presets(\"example_effect_id\")\n        &gt;&gt;&gt;     for preset in presets:\n        &gt;&gt;&gt;         print(f\"Preset ID: {preset.id}\")\n    \"\"\"\n    try:\n        async with self._request_context(\"GET\", f\"{LIGHTING_V1}/effects/{effect_id}/presets\") as data:\n            response = EffectPresetListResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            if response.data is None:\n                raise APIError(\"No preset data in the response\")\n            return response.data.items\n    except APIError as e:\n        if e.error and e.error.code == \"not_found\":\n            raise NotFoundError(f\"Effect with ID '{effect_id}' not found\", e.error) from e\n        raise\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_effects","title":"<code>get_effects()</code>  <code>async</code>","text":"<p>List available effects asynchronously.</p> <p>Returns:</p> Type Description <code>list[Effect]</code> <p>List[Effect]: A list of available effects.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an error retrieving the effects.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     effects = await client.get_effects()     print(f\"Found {len(effects)} effects\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_effects(self) -&gt; list[Effect]:\n    \"\"\"List available effects asynchronously.\n\n    Returns:\n        List[Effect]: A list of available effects.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an error retrieving the effects.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     effects = await client.get_effects()\n        &gt;&gt;&gt;     print(f\"Found {len(effects)} effects\")\n    \"\"\"\n    return await self._get_effects_cached()\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_effects_cached","title":"<code>get_effects_cached()</code>  <code>async</code>","text":"<p>Get effects with caching.</p> <p>Returns cached effects if available, otherwise retrieves them from the API.</p> <p>Returns:</p> Type Description <code>list[Effect]</code> <p>List[Effect]: A list of available effects.</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_effects_cached(self) -&gt; list[Effect]:\n    \"\"\"Get effects with caching.\n\n    Returns cached effects if available, otherwise retrieves them from the API.\n\n    Returns:\n        List[Effect]: A list of available effects.\n    \"\"\"\n    return await self._get_effects_cached()\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_enabled","title":"<code>get_enabled()</code>  <code>async</code>","text":"<p>Get the current enabled state of the canvas asynchronously.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>The current enabled state.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     enabled = await client.get_enabled()     print(f\"Canvas enabled: {enabled}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_enabled(self) -&gt; bool:\n    \"\"\"Get the current enabled state of the canvas asynchronously.\n\n    Returns:\n        bool: The current enabled state.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     enabled = await client.get_enabled()\n        &gt;&gt;&gt;     print(f\"Canvas enabled: {enabled}\")\n    \"\"\"\n    state = await self._get_current_state()\n    return state.attributes.enabled\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_layouts","title":"<code>get_layouts()</code>  <code>async</code>","text":"<p>Get all available layouts asynchronously.</p> <p>Returns:</p> Type Description <code>list[Layout]</code> <p>List[Layout]: A list of all available layouts.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     layouts = await client.get_layouts()     for layout in layouts:         print(f\"Layout: {layout.id}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_layouts(self) -&gt; list[Layout]:\n    \"\"\"Get all available layouts asynchronously.\n\n    Returns:\n        List[Layout]: A list of all available layouts.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     layouts = await client.get_layouts()\n        &gt;&gt;&gt;     for layout in layouts:\n        &gt;&gt;&gt;         print(f\"Layout: {layout.id}\")\n    \"\"\"\n    async with self._request_context(\"GET\", f\"{SCENES_V1}/layouts\") as data:\n        response = LayoutListResponse.from_dict(data)\n        self._ensure_response_ok(response)\n        if \"data\" not in data or \"items\" not in data[\"data\"]:\n            raise APIError(\"No layouts data in the response\")\n        return [Layout.from_dict(item) for item in data[\"data\"][\"items\"]]\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_next_effect","title":"<code>get_next_effect()</code>  <code>async</code>","text":"<p>Get information about the next effect in history asynchronously.</p> <p>Returns:</p> Type Description <code>Effect | None</code> <p>Optional[Effect]: The next effect if available, None otherwise.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     next_effect = await client.get_next_effect()     if next_effect:         print(f\"Next effect: {next_effect.attributes.name}\")     else:         print(\"No next effect available\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_next_effect(self) -&gt; Effect | None:\n    \"\"\"Get information about the next effect in history asynchronously.\n\n    Returns:\n        Optional[Effect]: The next effect if available, None otherwise.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     next_effect = await client.get_next_effect()\n        &gt;&gt;&gt;     if next_effect:\n        &gt;&gt;&gt;         print(f\"Next effect: {next_effect.attributes.name}\")\n        &gt;&gt;&gt;     else:\n        &gt;&gt;&gt;         print(\"No next effect available\")\n    \"\"\"\n    try:\n        async with self._request_context(\"GET\", f\"{LIGHTING_V1}/next\") as data:\n            response = EffectDetailsResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            return response.data\n    except APIError as e:\n        if e.error and e.error.code == \"409\":\n            return None\n        raise\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.get_previous_effect","title":"<code>get_previous_effect()</code>  <code>async</code>","text":"<p>Get information about the previous effect in history asynchronously.</p> <p>Returns:</p> Type Description <code>Effect | None</code> <p>Optional[Effect]: The previous effect if available, None otherwise.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     prev_effect = await client.get_previous_effect()     if prev_effect:         print(f\"Previous effect: {prev_effect.attributes.name}\")     else:         print(\"No previous effect available\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def get_previous_effect(self) -&gt; Effect | None:\n    \"\"\"Get information about the previous effect in history asynchronously.\n\n    Returns:\n        Optional[Effect]: The previous effect if available, None otherwise.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     prev_effect = await client.get_previous_effect()\n        &gt;&gt;&gt;     if prev_effect:\n        &gt;&gt;&gt;         print(f\"Previous effect: {prev_effect.attributes.name}\")\n        &gt;&gt;&gt;     else:\n        &gt;&gt;&gt;         print(\"No previous effect available\")\n    \"\"\"\n    try:\n        async with self._request_context(\"GET\", f\"{LIGHTING_V1}/previous\") as data:\n            response = EffectDetailsResponse.from_dict(data)\n            self._ensure_response_ok(response)\n            return response.data\n    except APIError as e:\n        if e.error and e.error.code == \"409\":\n            return None\n        raise\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.refresh_effects","title":"<code>refresh_effects()</code>  <code>async</code>","text":"<p>Refresh the cached effects asynchronously.</p> <p>This method clears the cache for the get_effects method, forcing a fresh retrieval of effects on the next call.</p> Example <p>async with AsyncSignalRGBClient() as client:     await client.refresh_effects()     fresh_effects = await client.get_effects()</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def refresh_effects(self) -&gt; None:\n    \"\"\"Refresh the cached effects asynchronously.\n\n    This method clears the cache for the get_effects method, forcing a fresh\n    retrieval of effects on the next call.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     await client.refresh_effects()\n        &gt;&gt;&gt;     fresh_effects = await client.get_effects()\n    \"\"\"\n    self._effects_cache = None\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.set_brightness","title":"<code>set_brightness(value)</code>  <code>async</code>","text":"<p>Set the brightness level asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The brightness level to set (0-100).</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     await client.set_brightness(75)     print(\"Brightness set to 75%\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def set_brightness(self, value: int) -&gt; None:\n    \"\"\"Set the brightness level asynchronously.\n\n    Args:\n        value: The brightness level to set (0-100).\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     await client.set_brightness(75)\n        &gt;&gt;&gt;     print(\"Brightness set to 75%\")\n    \"\"\"\n    async with self._request_context(\n        \"PATCH\",\n        f\"{LIGHTING_V1}/global_brightness\",\n        json={\"global_brightness\": value},\n    ):\n        pass\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.set_current_layout","title":"<code>set_current_layout(layout_id)</code>  <code>async</code>","text":"<p>Set the current layout asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>layout_id</code> <code>str</code> <p>The ID of the layout to set as current.</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     await client.set_current_layout(\"My Layout 1\")     current = await client.get_current_layout()     print(f\"New current layout: {current.id}\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def set_current_layout(self, layout_id: str) -&gt; None:\n    \"\"\"Set the current layout asynchronously.\n\n    Args:\n        layout_id: The ID of the layout to set as current.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     await client.set_current_layout(\"My Layout 1\")\n        &gt;&gt;&gt;     current = await client.get_current_layout()\n        &gt;&gt;&gt;     print(f\"New current layout: {current.id}\")\n    \"\"\"\n    async with self._request_context(\"PATCH\", f\"{SCENES_V1}/current_layout\", json={\"layout\": layout_id}) as data:\n        response = CurrentLayoutResponse.from_dict(data)\n        self._ensure_response_ok(response)\n        if response.data is None or response.data.current_layout is None:\n            raise APIError(\"No current layout data in the response\")\n        if response.data.current_layout.id != layout_id:\n            raise APIError(f\"Failed to set layout to '{layout_id}'\")\n</code></pre>"},{"location":"api/client/#signalrgb.async_client.AsyncSignalRGBClient.set_enabled","title":"<code>set_enabled(value)</code>  <code>async</code>","text":"<p>Set the enabled state of the canvas asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>Whether to enable the canvas.</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If there's a connection error.</p> <code>APIError</code> <p>If there's an API error.</p> <code>SignalRGBError</code> <p>For any other unexpected errors.</p> Example <p>async with AsyncSignalRGBClient() as client:     await client.set_enabled(False)     print(\"Canvas disabled\")</p> Source code in <code>signalrgb/async_client.py</code> <pre><code>async def set_enabled(self, value: bool) -&gt; None:\n    \"\"\"Set the enabled state of the canvas asynchronously.\n\n    Args:\n        value: Whether to enable the canvas.\n\n    Raises:\n        ConnectionError: If there's a connection error.\n        APIError: If there's an API error.\n        SignalRGBError: For any other unexpected errors.\n\n    Example:\n        &gt;&gt;&gt; async with AsyncSignalRGBClient() as client:\n        &gt;&gt;&gt;     await client.set_enabled(False)\n        &gt;&gt;&gt;     print(\"Canvas disabled\")\n    \"\"\"\n    async with self._request_context(\"PATCH\", f\"{LIGHTING_V1}/enabled\", json={\"enabled\": value}):\n        pass\n</code></pre>"},{"location":"api/client/#exceptions","title":"Exceptions","text":"<p>The SignalRGB client defines several custom exceptions for error handling:</p>"},{"location":"api/client/#signalrgb.exceptions.SignalRGBException","title":"<code>signalrgb.exceptions.SignalRGBException = SignalRGBError</code>  <code>module-attribute</code>","text":""},{"location":"api/client/#signalrgb.exceptions.ConnectionError","title":"<code>signalrgb.exceptions.ConnectionError</code>","text":"<p>               Bases: <code>SignalRGBError</code></p> <p>Exception raised for connection errors.</p> <p>This exception is raised when there's an issue connecting to the SignalRGB API.</p> Source code in <code>signalrgb/exceptions.py</code> <pre><code>class ConnectionError(SignalRGBError):\n    \"\"\"Exception raised for connection errors.\n\n    This exception is raised when there's an issue connecting to the SignalRGB API.\n    \"\"\"\n</code></pre>"},{"location":"api/client/#signalrgb.exceptions.APIError","title":"<code>signalrgb.exceptions.APIError</code>","text":"<p>               Bases: <code>SignalRGBError</code></p> <p>Exception raised for API errors.</p> <p>This exception is raised when the API returns an error response.</p> Source code in <code>signalrgb/exceptions.py</code> <pre><code>class APIError(SignalRGBError):\n    \"\"\"Exception raised for API errors.\n\n    This exception is raised when the API returns an error response.\n    \"\"\"\n</code></pre>"},{"location":"api/client/#signalrgb.exceptions.NotFoundError","title":"<code>signalrgb.exceptions.NotFoundError</code>","text":"<p>               Bases: <code>SignalRGBError</code></p> <p>Exception raised when an item is not found.</p> <p>This exception is raised when trying to retrieve or apply a non-existent effect, preset, or layout.</p> Source code in <code>signalrgb/exceptions.py</code> <pre><code>class NotFoundError(SignalRGBError):\n    \"\"\"Exception raised when an item is not found.\n\n    This exception is raised when trying to retrieve or apply a non-existent effect, preset, or layout.\n    \"\"\"\n</code></pre>"},{"location":"api/client/#usage-examples","title":"Usage Examples","text":""},{"location":"api/client/#synchronous-client-example","title":"Synchronous Client Example","text":"<pre><code>from signalrgb import SignalRGBClient\n\n# Initialize the client\nclient = SignalRGBClient(host=\"localhost\", port=16038)\n\n# Get all effects\neffects = client.get_effects()\nfor effect in effects:\n    print(f\"Effect: {effect.attributes.name}\")\n\n# Apply an effect\nclient.apply_effect_by_name(\"Rainbow Wave\")\n\n# Get current effect\ncurrent_effect = client.get_current_effect()\nprint(f\"Current effect: {current_effect.attributes.name}\")\n\n# Adjust brightness\nclient.brightness = 75\nprint(f\"Brightness set to: {client.brightness}\")\n</code></pre>"},{"location":"api/client/#asynchronous-client-example","title":"Asynchronous Client Example","text":"<pre><code>import asyncio\nfrom signalrgb import AsyncSignalRGBClient\n\nasync def main():\n    # Initialize the client using a context manager\n    async with AsyncSignalRGBClient(host=\"localhost\", port=16038) as client:\n        # Get all effects\n        effects = await client.get_effects()\n        for effect in effects:\n            print(f\"Effect: {effect.attributes.name}\")\n\n        # Apply an effect\n        await client.apply_effect_by_name(\"Rainbow Wave\")\n\n        # Get current effect\n        current_effect = await client.get_current_effect()\n        print(f\"Current effect: {current_effect.attributes.name}\")\n\n        # Adjust brightness\n        await client.set_brightness(75)\n        brightness = await client.get_brightness()\n        print(f\"Brightness set to: {brightness}\")\n\n# Run the async example\nasyncio.run(main())\n</code></pre> <p>For more detailed usage examples, please refer to: - Python Library Usage for the synchronous client - Asynchronous Library Usage for the async client</p>"},{"location":"api/models/","title":"SignalRGB Models API Reference","text":"<p>This page provides detailed API documentation for the data models used in the SignalRGB Python client. These models represent various data structures used in the SignalRGB API, including effects, responses, and error information.</p>"},{"location":"api/models/#core-models","title":"\ud83d\udd0d Core Models","text":""},{"location":"api/models/#attributes","title":"Attributes","text":""},{"location":"api/models/#signalrgb.model.Attributes","title":"<code>signalrgb.model.Attributes</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>Attributes of an effect in SignalRGB.</p> <p>This class represents the various properties and capabilities of an effect. It includes details such as the effect's name, description, publisher, and various flags indicating the effect's capabilities.</p> <p>Attributes:</p> Name Type Description <code>description</code> <code>Optional[str]</code> <p>A description of the effect.</p> <code>developer_effect</code> <code>bool</code> <p>Indicates whether this is a developer-created effect.</p> <code>image</code> <code>Optional[str]</code> <p>URL or path to the effect's image, if available.</p> <code>name</code> <code>str</code> <p>The name of the effect.</p> <code>parameters</code> <code>Dict[str, Any]</code> <p>A dictionary of effect-specific parameters.</p> <code>publisher</code> <code>Optional[str]</code> <p>The publisher or creator of the effect.</p> <code>uses_audio</code> <code>bool</code> <p>Indicates whether the effect uses audio input.</p> <code>uses_input</code> <code>bool</code> <p>Indicates whether the effect uses user input.</p> <code>uses_meters</code> <code>bool</code> <p>Indicates whether the effect uses meter data.</p> <code>uses_video</code> <code>bool</code> <p>Indicates whether the effect uses video input.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass Attributes(DataClassDictMixin):\n    \"\"\"\n    Attributes of an effect in SignalRGB.\n\n    This class represents the various properties and capabilities of an effect.\n    It includes details such as the effect's name, description, publisher, and various flags\n    indicating the effect's capabilities.\n\n    Attributes:\n        description (Optional[str]): A description of the effect.\n        developer_effect (bool): Indicates whether this is a developer-created effect.\n        image (Optional[str]): URL or path to the effect's image, if available.\n        name (str): The name of the effect.\n        parameters (Dict[str, Any]): A dictionary of effect-specific parameters.\n        publisher (Optional[str]): The publisher or creator of the effect.\n        uses_audio (bool): Indicates whether the effect uses audio input.\n        uses_input (bool): Indicates whether the effect uses user input.\n        uses_meters (bool): Indicates whether the effect uses meter data.\n        uses_video (bool): Indicates whether the effect uses video input.\n    \"\"\"\n\n    name: str\n    description: str | None = None\n    developer_effect: bool = False\n    image: str | None = None\n    parameters: dict[str, Any] = field(default_factory=dict)\n    publisher: str | None = None\n    uses_audio: bool = False\n    uses_input: bool = False\n    uses_meters: bool = False\n    uses_video: bool = False\n</code></pre>"},{"location":"api/models/#links","title":"Links","text":""},{"location":"api/models/#signalrgb.model.Links","title":"<code>signalrgb.model.Links</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>Links associated with an effect in SignalRGB.</p> <p>This class represents the URLs related to an effect, such as where to apply it or retrieve its details.</p> <p>Attributes:</p> Name Type Description <code>apply</code> <code>Optional[str]</code> <p>URL to apply the effect, if available.</p> <code>self_link</code> <code>Optional[str]</code> <p>URL of the effect itself, typically for retrieving its details.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass Links(DataClassDictMixin):\n    \"\"\"\n    Links associated with an effect in SignalRGB.\n\n    This class represents the URLs related to an effect, such as where to apply it\n    or retrieve its details.\n\n    Attributes:\n        apply (Optional[str]): URL to apply the effect, if available.\n        self_link (Optional[str]): URL of the effect itself, typically for retrieving its details.\n    \"\"\"\n\n    apply: str | None = None\n    self_link: str | None = None\n\n    class Config(BaseConfig):\n        aliases = {\"self_link\": \"self\"}\n</code></pre>"},{"location":"api/models/#effect","title":"Effect","text":""},{"location":"api/models/#signalrgb.model.Effect","title":"<code>signalrgb.model.Effect</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>Represents a single effect in SignalRGB.</p> <p>This class combines the attributes and links of an effect with its unique identifier. It provides a complete representation of an effect in the SignalRGB system.</p> <p>Attributes:</p> Name Type Description <code>attributes</code> <code>Attributes</code> <p>The attributes of the effect.</p> <code>id</code> <code>str</code> <p>Unique identifier of the effect.</p> <code>links</code> <code>Links</code> <p>Links associated with the effect.</p> <code>type</code> <code>str</code> <p>Type of the object, typically 'effect'.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass Effect(DataClassDictMixin):\n    \"\"\"\n    Represents a single effect in SignalRGB.\n\n    This class combines the attributes and links of an effect with its unique identifier.\n    It provides a complete representation of an effect in the SignalRGB system.\n\n    Attributes:\n        attributes (Attributes): The attributes of the effect.\n        id (str): Unique identifier of the effect.\n        links (Links): Links associated with the effect.\n        type (str): Type of the object, typically 'effect'.\n    \"\"\"\n\n    attributes: Attributes\n    id: str\n    links: Links\n    type: str\n</code></pre>"},{"location":"api/models/#effectlist","title":"EffectList","text":""},{"location":"api/models/#signalrgb.model.EffectList","title":"<code>signalrgb.model.EffectList</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>A list of effects in SignalRGB.</p> <p>This class is used to represent multiple effects, typically in API responses that return a collection of effects.</p> <p>Attributes:</p> Name Type Description <code>items</code> <code>List[Effect]</code> <p>A list of Effect objects.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass EffectList(DataClassDictMixin):\n    \"\"\"\n    A list of effects in SignalRGB.\n\n    This class is used to represent multiple effects, typically in API responses\n    that return a collection of effects.\n\n    Attributes:\n        items (List[Effect]): A list of Effect objects.\n    \"\"\"\n\n    items: list[Effect] = field(default_factory=list)\n</code></pre>"},{"location":"api/models/#state-models","title":"\ud83d\udee0\ufe0f State Models","text":""},{"location":"api/models/#currentstate","title":"CurrentState","text":""},{"location":"api/models/#signalrgb.model.CurrentState","title":"<code>signalrgb.model.CurrentState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>Represents the current state of a SignalRGB instance.</p> <p>This class includes the current state of the instance, such as the current effect, whether the canvas is enabled, and the global brightness level.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the current effect.</p> <code>enabled</code> <code>bool</code> <p>Indicates whether the canvas is currently enabled.</p> <code>global_brightness</code> <code>int</code> <p>The global brightness level of the canvas.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass CurrentState(DataClassDictMixin):\n    \"\"\"\n    Represents the current state of a SignalRGB instance.\n\n    This class includes the current state of the instance, such as the current effect,\n    whether the canvas is enabled, and the global brightness level.\n\n    Attributes:\n        name (str): The name of the current effect.\n        enabled (bool): Indicates whether the canvas is currently enabled.\n        global_brightness (int): The global brightness level of the canvas.\n    \"\"\"\n\n    name: str | None = None\n    enabled: bool = False\n    global_brightness: int = 0\n</code></pre>"},{"location":"api/models/#currentstateholder","title":"CurrentStateHolder","text":""},{"location":"api/models/#signalrgb.model.CurrentStateHolder","title":"<code>signalrgb.model.CurrentStateHolder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>Holds the current state and metadata</p> <p>Attributes:</p> Name Type Description <code>attributes</code> <code>Attributes</code> <p>The attributes of the state.</p> <code>id</code> <code>str</code> <p>Unique identifier of the current effect.</p> <code>links</code> <code>Links</code> <p>Links associated with the current effect.</p> <code>type</code> <code>str</code> <p>Type of the object, typically 'effect'.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass CurrentStateHolder(DataClassDictMixin):\n    \"\"\"\n    Holds the current state and metadata\n\n    Attributes:\n        attributes (Attributes): The attributes of the state.\n        id (str): Unique identifier of the current effect.\n        links (Links): Links associated with the current effect.\n        type (str): Type of the object, typically 'effect'.\n    \"\"\"\n\n    attributes: CurrentState\n    id: str\n    links: Links\n    type: str\n</code></pre>"},{"location":"api/models/#layout-models","title":"\ud83d\udcd0 Layout Models","text":""},{"location":"api/models/#layout","title":"Layout","text":""},{"location":"api/models/#signalrgb.model.Layout","title":"<code>signalrgb.model.Layout</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>Represents a layout in SignalRGB.</p> <p>This class represents a layout, which is a configuration of devices and their positions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The unique identifier of the layout.</p> <code>type</code> <code>str</code> <p>The type of the layout, typically 'layout'.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass Layout(DataClassDictMixin):\n    \"\"\"\n    Represents a layout in SignalRGB.\n\n    This class represents a layout, which is a configuration of devices and their positions.\n\n    Attributes:\n        id (str): The unique identifier of the layout.\n        type (str): The type of the layout, typically 'layout'.\n    \"\"\"\n\n    id: str\n    type: str\n</code></pre>"},{"location":"api/models/#layoutlist","title":"LayoutList","text":""},{"location":"api/models/#signalrgb.model.LayoutList","title":"<code>signalrgb.model.LayoutList</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>A list of layouts in SignalRGB.</p> <p>This class is used to represent a layout, typically in API responses that return a collection of layouts.</p> <p>Attributes:</p> Name Type Description <code>items</code> <code>List[Effect]</code> <p>A list of Layout objects.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass LayoutList(DataClassDictMixin):\n    \"\"\"\n    A list of layouts in SignalRGB.\n\n    This class is used to represent a layout, typically in API responses\n    that return a collection of layouts.\n\n    Attributes:\n        items (List[Effect]): A list of Layout objects.\n    \"\"\"\n\n    items: list[Layout] = field(default_factory=list)\n</code></pre>"},{"location":"api/models/#currentlayoutholder","title":"CurrentLayoutHolder","text":""},{"location":"api/models/#signalrgb.model.CurrentLayoutHolder","title":"<code>signalrgb.model.CurrentLayoutHolder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>Holds the current layout information.</p> <p>Attributes:</p> Name Type Description <code>current_layout</code> <code>Layout</code> <p>The current layout.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass CurrentLayoutHolder(DataClassDictMixin):\n    \"\"\"\n    Holds the current layout information.\n\n    Attributes:\n        current_layout (Layout): The current layout.\n    \"\"\"\n\n    current_layout: Layout\n</code></pre>"},{"location":"api/models/#preset-models","title":"\ud83d\udcbe Preset Models","text":""},{"location":"api/models/#effectpreset","title":"EffectPreset","text":""},{"location":"api/models/#signalrgb.model.EffectPreset","title":"<code>signalrgb.model.EffectPreset</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>Represents a preset for an effect in SignalRGB.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The unique identifier of the preset.</p> <code>type</code> <code>str</code> <p>The type of the preset, typically 'preset'.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass EffectPreset(DataClassDictMixin):\n    \"\"\"\n    Represents a preset for an effect in SignalRGB.\n\n    Attributes:\n        id (str): The unique identifier of the preset.\n        type (str): The type of the preset, typically 'preset'.\n    \"\"\"\n\n    id: str\n    type: str\n</code></pre>"},{"location":"api/models/#effectpresetlist","title":"EffectPresetList","text":""},{"location":"api/models/#signalrgb.model.EffectPresetList","title":"<code>signalrgb.model.EffectPresetList</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>A list of effect presets in SignalRGB.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the effect these presets belong to.</p> <code>items</code> <code>List[EffectPreset]</code> <p>A list of EffectPreset objects.</p> <code>type</code> <code>str</code> <p>The type of this object, typically 'presets'.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass EffectPresetList(DataClassDictMixin):\n    \"\"\"\n    A list of effect presets in SignalRGB.\n\n    Attributes:\n        id (str): The ID of the effect these presets belong to.\n        items (List[EffectPreset]): A list of EffectPreset objects.\n        type (str): The type of this object, typically 'presets'.\n    \"\"\"\n\n    id: str\n    items: list[EffectPreset] = field(default_factory=list)\n</code></pre>"},{"location":"api/models/#error-models","title":"\u26a0\ufe0f Error Models","text":""},{"location":"api/models/#error","title":"Error","text":""},{"location":"api/models/#signalrgb.model.Error","title":"<code>signalrgb.model.Error</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>Represents an error returned by the SignalRGB API.</p> <p>This class includes details about the error such as its code, title, and a detailed message. It is typically used when the API encounters an error during request processing.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>Optional[str]</code> <p>An error code, if provided by the API.</p> <code>detail</code> <code>Optional[str]</code> <p>A detailed error message explaining the issue.</p> <code>title</code> <code>str</code> <p>A brief title or summary of the error.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass Error(DataClassDictMixin):\n    \"\"\"\n    Represents an error returned by the SignalRGB API.\n\n    This class includes details about the error such as its code, title, and a detailed message.\n    It is typically used when the API encounters an error during request processing.\n\n    Attributes:\n        code (Optional[str]): An error code, if provided by the API.\n        detail (Optional[str]): A detailed error message explaining the issue.\n        title (str): A brief title or summary of the error.\n    \"\"\"\n\n    title: str\n    code: str | None = None\n    detail: str | None = None\n</code></pre>"},{"location":"api/models/#response-models","title":"\ud83d\udd04 Response Models","text":""},{"location":"api/models/#signalrgbresponse","title":"SignalRGBResponse","text":""},{"location":"api/models/#signalrgb.model.SignalRGBResponse","title":"<code>signalrgb.model.SignalRGBResponse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataClassDictMixin</code></p> <p>Base class for responses from the SignalRGB API.</p> <p>This class includes common fields found in all API responses. It serves as a base for more specific response types and provides a consistent structure for handling API responses.</p> <p>Attributes:</p> Name Type Description <code>api_version</code> <code>str</code> <p>The version of the API used for this response.</p> <code>id</code> <code>int</code> <p>A unique identifier for this response.</p> <code>method</code> <code>str</code> <p>The HTTP method used for the request that generated this response.</p> <code>params</code> <code>Dict[str, Any]</code> <p>Any parameters that were part of the request.</p> <code>status</code> <code>str</code> <p>The status of the response, typically 'ok' or 'error'.</p> <code>errors</code> <code>List[Error]</code> <p>A list of Error objects if any errors occurred.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass SignalRGBResponse(DataClassDictMixin):\n    \"\"\"\n    Base class for responses from the SignalRGB API.\n\n    This class includes common fields found in all API responses. It serves as a base\n    for more specific response types and provides a consistent structure for handling\n    API responses.\n\n    Attributes:\n        api_version (str): The version of the API used for this response.\n        id (int): A unique identifier for this response.\n        method (str): The HTTP method used for the request that generated this response.\n        params (Dict[str, Any]): Any parameters that were part of the request.\n        status (str): The status of the response, typically 'ok' or 'error'.\n        errors (List[Error]): A list of Error objects if any errors occurred.\n    \"\"\"\n\n    api_version: str\n    id: int\n    method: str\n    status: str\n    params: dict[str, Any] = field(default_factory=dict)\n    errors: list[Error] = field(default_factory=list)\n</code></pre>"},{"location":"api/models/#effectdetailsresponse","title":"EffectDetailsResponse","text":""},{"location":"api/models/#signalrgb.model.EffectDetailsResponse","title":"<code>signalrgb.model.EffectDetailsResponse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SignalRGBResponse</code></p> <p>Response model for requests that return details of a single effect.</p> <p>This class extends SignalRGBResponse and includes an additional field for the effect details.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Optional[Effect]</code> <p>The details of the requested effect, if available.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass EffectDetailsResponse(SignalRGBResponse):\n    \"\"\"\n    Response model for requests that return details of a single effect.\n\n    This class extends SignalRGBResponse and includes an additional field for\n    the effect details.\n\n    Attributes:\n        data (Optional[Effect]): The details of the requested effect, if available.\n    \"\"\"\n\n    data: Effect | None = None\n</code></pre>"},{"location":"api/models/#effectlistresponse","title":"EffectListResponse","text":""},{"location":"api/models/#signalrgb.model.EffectListResponse","title":"<code>signalrgb.model.EffectListResponse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SignalRGBResponse</code></p> <p>Response model for requests that return a list of effects.</p> <p>This class extends SignalRGBResponse and includes an additional field for the list of effects.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Optional[EffectList]</code> <p>The list of effects returned by the API, if available.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass EffectListResponse(SignalRGBResponse):\n    \"\"\"\n    Response model for requests that return a list of effects.\n\n    This class extends SignalRGBResponse and includes an additional field for\n    the list of effects.\n\n    Attributes:\n        data (Optional[EffectList]): The list of effects returned by the API, if available.\n    \"\"\"\n\n    data: EffectList | None = None\n</code></pre>"},{"location":"api/models/#currentstateresponse","title":"CurrentStateResponse","text":""},{"location":"api/models/#signalrgb.model.CurrentStateResponse","title":"<code>signalrgb.model.CurrentStateResponse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SignalRGBResponse</code></p> <p>Response model for requests that return the current state of the canvas.</p> <p>This class extends SignalRGBResponse and includes an additional field for the current state of the canvas.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Optional[CurrentStateHolder]</code> <p>The current state of the canvas, if available.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass CurrentStateResponse(SignalRGBResponse):\n    \"\"\"\n    Response model for requests that return the current state of the canvas.\n\n    This class extends SignalRGBResponse and includes an additional field for\n    the current state of the canvas.\n\n    Attributes:\n        data (Optional[CurrentStateHolder]): The current state of the canvas, if available.\n    \"\"\"\n\n    data: CurrentStateHolder | None = None\n</code></pre>"},{"location":"api/models/#layoutlistresponse","title":"LayoutListResponse","text":""},{"location":"api/models/#signalrgb.model.LayoutListResponse","title":"<code>signalrgb.model.LayoutListResponse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SignalRGBResponse</code></p> <p>Response model for requests that return a list of layouts.</p> <p>This class extends SignalRGBResponse and includes an additional field for the list of layouts.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Optional[Dict[str, Any]]</code> <p>The data containing the list of layouts returned by the API, if available.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass LayoutListResponse(SignalRGBResponse):\n    \"\"\"\n    Response model for requests that return a list of layouts.\n\n    This class extends SignalRGBResponse and includes an additional field for\n    the list of layouts.\n\n    Attributes:\n        data (Optional[Dict[str, Any]]): The data containing the list of layouts returned by the API, if available.\n    \"\"\"\n\n    data: dict[str, Any] | None = None\n</code></pre>"},{"location":"api/models/#currentlayoutresponse","title":"CurrentLayoutResponse","text":""},{"location":"api/models/#signalrgb.model.CurrentLayoutResponse","title":"<code>signalrgb.model.CurrentLayoutResponse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SignalRGBResponse</code></p> <p>Response model for requests that return the current layout.</p> <p>This class extends SignalRGBResponse and includes an additional field for the current layout.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Optional[CurrentLayoutHolder]</code> <p>The data containing the current layout returned by the API, if available.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass CurrentLayoutResponse(SignalRGBResponse):\n    \"\"\"\n    Response model for requests that return the current layout.\n\n    This class extends SignalRGBResponse and includes an additional field for\n    the current layout.\n\n    Attributes:\n        data (Optional[CurrentLayoutHolder]): The data containing the current layout returned by the API, if available.\n    \"\"\"\n\n    data: CurrentLayoutHolder | None = None\n</code></pre>"},{"location":"api/models/#effectpresetlistresponse","title":"EffectPresetListResponse","text":""},{"location":"api/models/#signalrgb.model.EffectPresetListResponse","title":"<code>signalrgb.model.EffectPresetListResponse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SignalRGBResponse</code></p> <p>Response model for requests that return a list of effect presets.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Optional[EffectPresetList]</code> <p>The list of effect presets returned by the API, if available.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass EffectPresetListResponse(SignalRGBResponse):\n    \"\"\"\n    Response model for requests that return a list of effect presets.\n\n    Attributes:\n        data (Optional[EffectPresetList]): The list of effect presets returned by the API, if available.\n    \"\"\"\n\n    data: EffectPresetList | None = None\n</code></pre>"},{"location":"api/models/#effectpresetresponse","title":"EffectPresetResponse","text":""},{"location":"api/models/#signalrgb.model.EffectPresetResponse","title":"<code>signalrgb.model.EffectPresetResponse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SignalRGBResponse</code></p> <p>Response model for requests that return details of a single effect preset.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Optional[EffectPreset]</code> <p>The details of the requested effect preset, if available.</p> Source code in <code>signalrgb/model.py</code> <pre><code>@dataclass\nclass EffectPresetResponse(SignalRGBResponse):\n    \"\"\"\n    Response model for requests that return details of a single effect preset.\n\n    Attributes:\n        data (Optional[EffectPreset]): The details of the requested effect preset, if available.\n    \"\"\"\n\n    data: EffectPreset | None = None\n</code></pre>"},{"location":"api/models/#usage-example","title":"\ud83d\udca1 Usage Example","text":"<p>Here's a basic example of how to work with these models:</p> <pre><code>from signalrgb import SignalRGBClient\nfrom signalrgb.model import Effect, Attributes\n\n# Initialize the client\nclient = SignalRGBClient()\n\n# Get an effect\neffect: Effect = client.get_effect_by_name(\"Sakura\")\n\n# Access effect attributes\nprint(f\"Effect name: {effect.attributes.name}\")\nprint(f\"Effect description: {effect.attributes.description}\")\nprint(f\"Effect uses audio: {effect.attributes.uses_audio}\")\n\n# Extract parameters\nparameters = effect.attributes.parameters\nfor param_name, param_data in parameters.items():\n    print(f\"Parameter: {param_name}\")\n    print(f\"  Type: {param_data.get('type', 'Unknown')}\")\n    print(f\"  Value: {param_data.get('value')}\")\n\n# Working with async client\nimport asyncio\nfrom signalrgb import AsyncSignalRGBClient\n\nasync def get_effect_info():\n    async with AsyncSignalRGBClient() as client:\n        effect = await client.get_effect_by_name(\"Rainbow Wave\")\n        return effect.attributes.name, effect.id\n\n# Run the async code\nname, effect_id = asyncio.run(get_effect_info())\nprint(f\"Got effect: {name} with ID: {effect_id}\")\n</code></pre> <p>For more detailed usage examples, please refer to: - Python Library Usage for the synchronous client - Asynchronous Library Usage for the async client</p>"},{"location":"usage/cli/","title":"Command-Line Interface (CLI) Usage","text":"<p>signalrgb-python provides a user-friendly command-line interface for interacting with your SignalRGB setup. This guide covers the basic usage of the CLI.</p>"},{"location":"usage/cli/#basic-syntax","title":"\ud83d\ude80 Basic Syntax","text":"<p>The basic syntax for using the SignalRGB CLI is:</p> <pre><code>signalrgb [OPTIONS] COMMAND [SUBCOMMAND] [ARGS]...\n</code></pre> <p>You can always use the <code>--help</code> option to get more information about available commands and options:</p> <pre><code>signalrgb --help\n</code></pre>"},{"location":"usage/cli/#available-commands","title":"\ud83d\udccb Available Commands","text":""},{"location":"usage/cli/#effect-commands","title":"\ud83c\udfa8 Effect Commands","text":""},{"location":"usage/cli/#list-effects","title":"List Effects","text":"<p>To list all available lighting effects:</p> <pre><code>signalrgb effect list\n</code></pre>"},{"location":"usage/cli/#get-effect-details","title":"Get Effect Details","text":"<p>To get detailed information about a specific effect:</p> <pre><code>signalrgb effect \"Effect Name\"\n</code></pre> <p>Replace \"Effect Name\" with the name of the effect you want to inspect.</p>"},{"location":"usage/cli/#apply-an-effect","title":"Apply an Effect","text":"<p>To apply a specific effect:</p> <pre><code>signalrgb effect apply \"Effect Name\"\n</code></pre>"},{"location":"usage/cli/#get-current-effect","title":"Get Current Effect","text":"<p>To see which effect is currently active:</p> <pre><code>signalrgb effect\n</code></pre>"},{"location":"usage/cli/#navigate-through-effects","title":"Navigate Through Effects","text":"<p>To apply the next effect in history:</p> <pre><code>signalrgb effect next_effect\n</code></pre> <p>To apply the previous effect in history:</p> <pre><code>signalrgb effect previous_effect\n</code></pre> <p>To apply a random effect:</p> <pre><code>signalrgb effect random\n</code></pre>"},{"location":"usage/cli/#preset-commands","title":"\ud83d\udcbe Preset Commands","text":""},{"location":"usage/cli/#list-presets","title":"List Presets","text":"<p>To list presets for the current effect:</p> <pre><code>signalrgb preset list\n</code></pre>"},{"location":"usage/cli/#apply-a-preset","title":"Apply a Preset","text":"<p>To apply a preset to the current effect:</p> <pre><code>signalrgb preset apply \"Preset Name\"\n</code></pre>"},{"location":"usage/cli/#layout-commands","title":"\ud83d\udcd0 Layout Commands","text":""},{"location":"usage/cli/#list-layouts","title":"List Layouts","text":"<p>To list all available layouts:</p> <pre><code>signalrgb layout list\n</code></pre>"},{"location":"usage/cli/#set-current-layout","title":"Set Current Layout","text":"<p>To set the current layout:</p> <pre><code>signalrgb layout set \"Layout Name\"\n</code></pre>"},{"location":"usage/cli/#canvas-commands","title":"\ud83c\udf9b\ufe0f Canvas Commands","text":""},{"location":"usage/cli/#control-brightness","title":"Control Brightness","text":"<p>To set the brightness level (0-100):</p> <pre><code>signalrgb canvas brightness 75\n</code></pre> <p>To get the current brightness level:</p> <pre><code>signalrgb canvas brightness\n</code></pre>"},{"location":"usage/cli/#enabledisable-canvas","title":"Enable/Disable Canvas","text":"<p>To enable the canvas:</p> <pre><code>signalrgb canvas enable\n</code></pre> <p>To disable the canvas:</p> <pre><code>signalrgb canvas disable\n</code></pre> <p>To toggle the canvas state:</p> <pre><code>signalrgb canvas toggle\n</code></pre>"},{"location":"usage/cli/#global-options","title":"\ud83c\udf10 Global Options","text":"<p>You can specify a custom host and port for all commands:</p> <pre><code>signalrgb --host my-pc.local --port 16038 effect list\n</code></pre>"},{"location":"usage/cli/#examples","title":"\ud83d\udca1 Examples","text":"<p>Here are some example use cases:</p> <ol> <li>List all effects and pipe the output to <code>grep</code> to find a specific effect:</li> </ol> <pre><code>signalrgb effect list | grep \"Electric Space\"\n</code></pre> <ol> <li>Apply the \"Rave Visualizer\" effect:</li> </ol> <pre><code>signalrgb effect apply \"Rave Visualizer\"\n</code></pre> <ol> <li>Get details of the current effect and save it to a file:</li> </ol> <pre><code>signalrgb effect &gt; current_effect.txt\n</code></pre> <ol> <li>Set the brightness to 50% and then disable the canvas:</li> </ol> <pre><code>signalrgb canvas brightness 50\nsignalrgb canvas disable\n</code></pre> <ol> <li>List layouts and switch to a different one:</li> </ol> <pre><code>signalrgb layout list\nsignalrgb layout set \"Gaming Setup\"\n</code></pre> <ol> <li>Create a simple effect cycle script:</li> </ol> <pre><code>#!/bin/bash\n# Cycle through 5 random effects\nfor i in {1..5}; do\n  signalrgb effect random\n  sleep 5  # Wait 5 seconds between effects\ndone\n</code></pre> <p>Remember to refer to the <code>--help</code> option for each command to see all available options and arguments:</p> <pre><code>signalrgb effect --help\nsignalrgb preset --help\nsignalrgb layout --help\nsignalrgb canvas --help\n</code></pre>"},{"location":"usage/library/","title":"Python Library Usage","text":"<p>signalrgb-python can be easily integrated into your Python projects. This guide covers the basic usage of the synchronous library. For asyncio-based applications, see the Async Client Usage guide.</p>"},{"location":"usage/library/#initializing-the-client","title":"\ud83d\ude80 Initializing the Client","text":"<p>First, import the <code>SignalRGBClient</code> class and create an instance:</p> <pre><code>from signalrgb import SignalRGBClient\n\n# Default connection (localhost:16038)\nclient = SignalRGBClient()\n\n# Or specify custom connection parameters\nclient = SignalRGBClient(host=\"192.168.1.100\", port=16038, timeout=5.0)\n</code></pre> <p>The client can also be used as a context manager to ensure proper cleanup of resources:</p> <pre><code>with SignalRGBClient() as client:\n    # Client will be automatically closed when exiting the block\n    current_effect = client.get_current_effect()\n</code></pre>"},{"location":"usage/library/#working-with-effects","title":"\ud83c\udfa8 Working with Effects","text":""},{"location":"usage/library/#listing-effects","title":"Listing Effects","text":"<p>To get a list of all available effects:</p> <pre><code>effects = client.get_effects()\nfor effect in effects:\n    print(f\"Effect: {effect.attributes.name}\")\n    print(f\"Description: {effect.attributes.description}\")\n</code></pre>"},{"location":"usage/library/#getting-effect-details","title":"Getting Effect Details","text":"<p>To get detailed information about a specific effect:</p> <pre><code># By name\neffect = client.get_effect_by_name(\"Rain\")\nprint(f\"Effect Name: {effect.attributes.name}\")\nprint(f\"Description: {effect.attributes.description}\")\nprint(f\"Uses Audio: {effect.attributes.uses_audio}\")\n\n# By ID\neffect = client.get_effect(\"effect_id_123\")\n</code></pre>"},{"location":"usage/library/#applying-an-effect","title":"Applying an Effect","text":"<p>To apply a specific effect:</p> <pre><code># By name\nclient.apply_effect_by_name(\"Rainbow Wave\")\n\n# By ID\nclient.apply_effect(\"effect_id_123\")\n</code></pre>"},{"location":"usage/library/#getting-the-current-effect","title":"Getting the Current Effect","text":"<p>To see which effect is currently active:</p> <pre><code>current_effect = client.get_current_effect()\nprint(f\"Current Effect: {current_effect.attributes.name}\")\n</code></pre>"},{"location":"usage/library/#effect-navigation-and-random-effects","title":"Effect Navigation and Random Effects","text":"<p>Navigate through effects or apply a random effect:</p> <pre><code># Apply the next effect in history\nnext_effect = client.apply_next_effect()\nprint(f\"Applied next effect: {next_effect.attributes.name}\")\n\n# Apply the previous effect in history\nprev_effect = client.apply_previous_effect()\nprint(f\"Applied previous effect: {prev_effect.attributes.name}\")\n\n# Apply a random effect\nrandom_effect = client.apply_random_effect()\nprint(f\"Applied random effect: {random_effect.attributes.name}\")\n</code></pre>"},{"location":"usage/library/#working-with-presets","title":"\ud83c\udf1f Working with Presets","text":""},{"location":"usage/library/#listing-presets","title":"Listing Presets","text":"<p>To get a list of presets for a specific effect:</p> <pre><code>effect_id = client.get_current_effect().id\npresets = client.get_effect_presets(effect_id)\nfor preset in presets:\n    print(f\"Preset: {preset.id}\")\n</code></pre>"},{"location":"usage/library/#applying-a-preset","title":"Applying a Preset","text":"<p>To apply a preset to the current effect:</p> <pre><code>effect_id = client.get_current_effect().id\nclient.apply_effect_preset(effect_id, \"Cool Preset\")\n</code></pre>"},{"location":"usage/library/#working-with-layouts","title":"\ud83d\udcd0 Working with Layouts","text":""},{"location":"usage/library/#listing-layouts","title":"Listing Layouts","text":"<p>To get a list of all available layouts:</p> <pre><code>layouts = client.get_layouts()\nfor layout in layouts:\n    print(f\"Layout: {layout.id}\")\n</code></pre>"},{"location":"usage/library/#setting-the-current-layout","title":"Setting the Current Layout","text":"<p>To set the current layout:</p> <pre><code># Using the property\nclient.current_layout = \"Gaming Setup\"\n\n# Check the current layout\nprint(f\"Current Layout: {client.current_layout.id}\")\n</code></pre>"},{"location":"usage/library/#controlling-the-canvas","title":"\ud83c\udf9b\ufe0f Controlling the Canvas","text":""},{"location":"usage/library/#brightness-control","title":"Brightness Control","text":"<p>The brightness level can be adjusted from 0 to 100:</p> <pre><code># Get current brightness\nbrightness = client.brightness\nprint(f\"Current brightness: {brightness}\")\n\n# Set brightness to 75%\nclient.brightness = 75\nprint(f\"Brightness set to: {client.brightness}\")\n</code></pre>"},{"location":"usage/library/#enablingdisabling-the-canvas","title":"Enabling/Disabling the Canvas","text":"<p>To control the enabled state of the canvas:</p> <pre><code># Get current state\nenabled = client.enabled\nprint(f\"Canvas enabled: {enabled}\")\n\n# Enable the canvas\nclient.enabled = True\nprint(f\"Canvas enabled: {client.enabled}\")\n\n# Disable the canvas\nclient.enabled = False\nprint(f\"Canvas disabled: {client.enabled}\")\n</code></pre>"},{"location":"usage/library/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":"<p>The client provides custom exceptions for different types of errors. You can handle these exceptions to provide better error messages or implement retry logic:</p> <pre><code>from signalrgb import SignalRGBClient, ConnectionError, APIError, NotFoundError\n\nclient = SignalRGBClient()\n\ntry:\n    client.apply_effect_by_name(\"Non-existent Effect\")\nexcept ConnectionError as e:\n    print(f\"Connection failed: {e}\")\nexcept NotFoundError as e:\n    print(f\"Effect not found: {e}\")\nexcept APIError as e:\n    print(f\"API error occurred: {e}\")\n</code></pre>"},{"location":"usage/library/#cache-management","title":"\ud83d\udd04 Cache Management","text":"<p>The client caches the list of effects for performance. If you need to refresh this cache:</p> <pre><code>client.refresh_effects()\neffects = client.get_effects()  # Will fetch the latest effects\n</code></pre>"},{"location":"usage/library/#working-with-effect-parameters","title":"\ud83d\udd0d Working with Effect Parameters","text":"<p>Some effects have parameters that can be adjusted. You can access these parameters by examining the effect's attributes:</p> <pre><code>effect = client.get_effect_by_name(\"Falling Stars\")\nparameters = effect.attributes.parameters\n\n# Print all parameters\nfor param_name, param_data in parameters.items():\n    print(f\"Parameter: {param_name}\")\n    print(f\"  Type: {param_data.get('type', 'Unknown')}\")\n    print(f\"  Value: {param_data.get('value')}\")\n</code></pre> <p>Note that the structure of parameters can vary between effects. Always check the specific effect's parameters to understand what options are available.</p>"},{"location":"usage/library/#using-the-synchronous-client-from-async-code","title":"\ud83d\udd04 Using the Synchronous Client from Async Code","text":"<p>If you have mostly async code but need to use the synchronous client in a few places, wrap the client methods in async functions:</p> <pre><code>import asyncio\nfrom signalrgb import SignalRGBClient\n\nasync def get_effects_async():\n    # Run the synchronous client in a thread pool\n    loop = asyncio.get_running_loop()\n    client = SignalRGBClient()\n\n    return await loop.run_in_executor(\n        None, client.get_effects\n    )\n\n# Use it in async code\nasync def main():\n    effects = await get_effects_async()\n    print(f\"Found {len(effects)} effects\")\n\n# Or consider using the AsyncSignalRGBClient instead\n</code></pre> <p>However, for proper async applications, it's recommended to use the <code>AsyncSignalRGBClient</code> directly as shown in the Async Client Usage guide.</p>"},{"location":"usage/library/#complete-example","title":"\ud83d\udccb Complete Example","text":"<p>Here's a more comprehensive example that demonstrates various features of the signalrgb-python library:</p> <pre><code>from signalrgb import SignalRGBClient, ConnectionError, APIError, NotFoundError\n\ndef main():\n    try:\n        # Initialize the client\n        client = SignalRGBClient(host=\"localhost\", port=16038)\n\n        # List all effects\n        print(\"Available effects:\")\n        effects = client.get_effects()\n        for effect in effects:\n            print(f\"- {effect.attributes.name}\")\n\n        # Get details of a specific effect\n        effect_name = \"Rainbow Wave\"\n        effect = client.get_effect_by_name(effect_name)\n        print(f\"\\nDetails of '{effect_name}':\")\n        print(f\"Description: {effect.attributes.description}\")\n        print(f\"Uses Audio: {effect.attributes.uses_audio}\")\n\n        # Apply the effect\n        client.apply_effect_by_name(effect_name)\n        print(f\"\\nApplied effect: {effect_name}\")\n\n        # Get current effect\n        current_effect = client.get_current_effect()\n        print(f\"Current effect: {current_effect.attributes.name}\")\n\n        # Adjust brightness\n        client.brightness = 75\n        print(f\"Brightness set to: {client.brightness}\")\n\n        # Enable/disable the canvas\n        client.enabled = True\n        print(f\"Canvas enabled: {client.enabled}\")\n\n        # List layouts\n        layouts = client.get_layouts()\n        print(\"\\nAvailable layouts:\")\n        for layout in layouts:\n            print(f\"- {layout.id}\")\n\n        # Apply a random effect\n        random_effect = client.apply_random_effect()\n        print(f\"\\nApplied random effect: {random_effect.attributes.name}\")\n\n    except ConnectionError as e:\n        print(f\"Connection error: {e}\")\n    except NotFoundError as e:\n        print(f\"Resource not found: {e}\")\n    except APIError as e:\n        print(f\"API error: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"usage/library/#best-practices","title":"\ud83d\udca1 Best Practices","text":"<ol> <li> <p>Error Handling: Always wrap your code in try-except blocks to handle potential errors gracefully.</p> </li> <li> <p>Resource Management: Use the client as a context manager when possible to ensure proper cleanup.</p> </li> <li> <p>Caching: The <code>get_effects()</code> method uses caching to improve performance. If you need the most up-to-date list, call <code>refresh_effects()</code> first.</p> </li> <li> <p>Rate Limiting: Be mindful of how frequently you're making requests, especially in loops or automated scripts.</p> </li> <li> <p>Async Support: For asyncio-based applications, consider using the <code>AsyncSignalRGBClient</code> instead.</p> </li> </ol>"}]}